
<!DOCTYPE html>

<html>
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" /><meta name="generator" content="Docutils 0.17.1: http://docutils.sourceforge.net/" />

    <title>2. Programs in files &#8212; Object oriented programming in Python for mathematicians 2021.0 documentation</title>
    <link rel="stylesheet" type="text/css" href="_static/pygments.css" />
    <link rel="stylesheet" type="text/css" href="_static/fenics.css" />
    <link rel="stylesheet" type="text/css" href="_static/proof.css" />
    <link rel="stylesheet" type="text/css" href="_static/graphviz.css" />
    <link rel="stylesheet" type="text/css" href="_static/panels-main.c949a650a448cc0ae9fd3441c0e17fb0.css" />
    <link rel="stylesheet" type="text/css" href="_static/panels-bootstrap.5fd3999ee7762ccc51105388f4a9d115.css" />
    <link rel="stylesheet" type="text/css" href="_static/panels-variables.06eb56fa6e07937060861dad626602ad.css" />
    <script data-url_root="./" id="documentation_options" src="_static/documentation_options.js"></script>
    <script src="_static/jquery.js"></script>
    <script src="_static/underscore.js"></script>
    <script src="_static/doctools.js"></script>
    <script src="_static/proof.js"></script>
    <link rel="index" title="Index" href="genindex.html" />
    <link rel="search" title="Search" href="search.html" />
    <link rel="next" title="3. Objects and abstraction" href="3_objects.html" />
    <link rel="prev" title="1. Introduction: abstraction in mathematics and programming" href="1_introduction.html" />
<!--[if lte IE 6]>
<link rel="stylesheet" href="_static/ie6.css" type="text/css" media="screen" charset="utf-8" />
<![endif]-->
<!-- Global site tag (gtag.js) - Google Analytics -->
<script async src="https://www.googletagmanager.com/gtag/js?id=G-0EFVH5C4DC"></script>
<script>
  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());

  gtag('config', 'G-0EFVH5C4DC');
</script>
<link rel="stylesheet" href="_static/featured.css">


<link rel="shortcut icon" href="_static/icon.ico" />


  </head><body>
<div class="wrapper">
  <div id="access">
    <div class="menu">
      <ul>
          <li class="page_item"><a href="https://github.com/oxmmscpython/object-oriented-programming" title="GitHub">GitHub</a></li>
      </ul>
    </div><!-- .menu -->
  </div><!-- #access -->
</div><!-- #wrapper -->


    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body" role="main">
            
  <section id="programs-in-files">
<span id="programs-files"></span><h1><span class="section-number">2. </span>Programs in files<a class="headerlink" href="#programs-in-files" title="Permalink to this headline">¶</a></h1>
<p>This week we will start to learn how to combine pieces of code into larger units,
and how to package up your code so that you or others can do the same.
You might previously have written Python code in Jupyter notebooks, and
possibly used an interactive Python environment such as
iPython. Such Jupyter notebooks are an excellent platform for writing and
documenting short pieces of code. However, they are much less good for
writing code which is designed to be used by other people. If the
intention is to write mathematical building blocks out of which more
complex algorithms can be constructed, then we need a different way of
storing code: one which is accessible in more automated ways than
typing in a web browser. As an introduction to writing code in files,
we will first consider Python scripts. We’ll then move on to making
code really reusable by creating Python modules and packages.</p>
<section id="setting-up-a-python-environment-for-this-course">
<h2><span class="section-number">2.1. </span>Setting up a Python environment for this course<a class="headerlink" href="#setting-up-a-python-environment-for-this-course" title="Permalink to this headline">¶</a></h2>
<details class="sphinx-bs dropdown card mb-3">
<summary class="summary-title card-header">
Video: setting up your virtual environment.<div class="summary-down docutils">
<svg version="1.1" width="24" height="24" class="octicon octicon-chevron-down" viewBox="0 0 24 24" aria-hidden="true"><path fill-rule="evenodd" d="M5.22 8.72a.75.75 0 000 1.06l6.25 6.25a.75.75 0 001.06 0l6.25-6.25a.75.75 0 00-1.06-1.06L12 14.44 6.28 8.72a.75.75 0 00-1.06 0z"></path></svg></div>
<div class="summary-up docutils">
<svg version="1.1" width="24" height="24" class="octicon octicon-chevron-up" viewBox="0 0 24 24" aria-hidden="true"><path fill-rule="evenodd" d="M18.78 15.28a.75.75 0 000-1.06l-6.25-6.25a.75.75 0 00-1.06 0l-6.25 6.25a.75.75 0 101.06 1.06L12 9.56l5.72 5.72a.75.75 0 001.06 0z"></path></svg></div>
</summary><div class="summary-content card-body docutils">
<div class="vimeo docutils container">
<iframe src="https://player.vimeo.com/video/486546635"
frameborder="0" allow="autoplay; fullscreen"
allowfullscreen></iframe></div>
</div>
</details><p>During this course, we’re going to create, edit, and install a whole bunch of
Python packages. In order to have a predictable programming environment in which
the experiments we’re doing don’t interfere with anything outside the course for
which we might be using Python, and conversely to ensure that nothing we’ve
installed elsewhere interferes with how we’re doing the course, we’ll do
everything in a Python <a class="reference internal" href="#term-virtual-environment"><span class="xref std std-term">virtual environment</span></a>, or <a class="reference internal" href="#term-venv"><span class="xref std std-term">venv</span></a>. You should read up on Python
virtual environments on the <a class="reference external" href="https://imperial-fons-computing.github.io/python.html#python-virtual-environments" title="(in Installation instructions for FoNS v2020.0)"><span class="xref std std-ref">Python installation
page</span></a>.</p>
<div class="admonition hint">
<p class="admonition-title">Hint</p>
<p>Don’t forget that you need to activate the venv in every new <a class="reference external" href="https://imperial-fons-computing.github.io/terminal.html#terminal" title="(in Installation instructions for FoNS v2020.0)"><span class="xref std std-ref">terminal</span></a> session.</p>
</div>
</section>
<section id="installing-python-packages">
<h2><span class="section-number">2.2. </span>Installing Python packages<a class="headerlink" href="#installing-python-packages" title="Permalink to this headline">¶</a></h2>
<p>Suppose we’ve created and activated a venv, and now there’s a Python
package we’d like to have access to. Installation of Python packages
is handled by <a class="reference external" href="https://pip.pypa.io/en/stable/" title="(in pip v22.0)"><span>pip</span></a>. Pip has many usage options, which
enable a large number of different installation
configurations. However, for most users most of the time, a few simple
pip commands suffice. As with <a class="reference internal" href="#term-venv"><span class="xref std std-term">venv</span></a> creation, package
installation is best accomplished from the terminal and not from
within Python itself. Don’t forget to activate the venv!</p>
<section id="installing-packages-from-pypi">
<h3><span class="section-number">2.2.1. </span>Installing packages from PyPI<a class="headerlink" href="#installing-packages-from-pypi" title="Permalink to this headline">¶</a></h3>
<p><a class="reference external" href="https://pypi.org">PyPI</a> is the Python Package Index. It is the
official download location for publicly released Python packages which
aren’t themselves a part of the built-in <a class="reference external" href="https://docs.python.org/3/library/index.html" title="(in Python v3.10)"><span class="xref std std-doc">Python Standard Library</span></a>. Many important mathematical packages
including <a class="reference external" href="https://numpy.org/doc/stable/reference/index.html#module-numpy" title="(in NumPy v1.22)"><code class="xref py py-mod docutils literal notranslate"><span class="pre">numpy</span></code></a> and <a class="reference external" href="https://www.sympy.org">sympy</a> are
distributed from PyPI. Suppose your venv doesn’t have <a class="reference external" href="https://numpy.org/doc/stable/reference/index.html#module-numpy" title="(in NumPy v1.22)"><code class="xref py py-mod docutils literal notranslate"><span class="pre">numpy</span></code></a>
installed and you need it. You would install it with the following
terminal command:</p>
<div class="highlight-console notranslate"><div class="highlight"><pre><span></span><span class="gp gp-VirtualEnv">(my_venv)</span> <span class="gp">$ </span>python -m pip install numpy
</pre></div>
</div>
<p>It is also possible to invoke pip directly using the command <code class="xref py py-obj docutils literal notranslate"><span class="pre">pip3</span></code>,
but there are some circumstances where that might result in pip using
the wrong Python installation. The approach used here is safer.</p>
<p>Python packages may depend on other Python packages, so it’s quite
likely that pip will install more packages than those you directly
asked for. This is necessary if those packages are to actually work.</p>
<p>Pip can also be used to upgrade a package to the latest version:</p>
<div class="highlight-console notranslate"><div class="highlight"><pre><span></span><span class="gp gp-VirtualEnv">(my_venv)</span> <span class="gp">$ </span>python -m pip install --upgrade numpy
</pre></div>
</div>
</section>
</section>
<section id="the-python-interpreter">
<h2><span class="section-number">2.3. </span>The Python interpreter<a class="headerlink" href="#the-python-interpreter" title="Permalink to this headline">¶</a></h2>
<details class="sphinx-bs dropdown card mb-3">
<summary class="summary-title card-header">
Video: a first Python script.<div class="summary-down docutils">
<svg version="1.1" width="24" height="24" class="octicon octicon-chevron-down" viewBox="0 0 24 24" aria-hidden="true"><path fill-rule="evenodd" d="M5.22 8.72a.75.75 0 000 1.06l6.25 6.25a.75.75 0 001.06 0l6.25-6.25a.75.75 0 00-1.06-1.06L12 14.44 6.28 8.72a.75.75 0 00-1.06 0z"></path></svg></div>
<div class="summary-up docutils">
<svg version="1.1" width="24" height="24" class="octicon octicon-chevron-up" viewBox="0 0 24 24" aria-hidden="true"><path fill-rule="evenodd" d="M18.78 15.28a.75.75 0 000-1.06l-6.25-6.25a.75.75 0 00-1.06 0l-6.25 6.25a.75.75 0 101.06 1.06L12 9.56l5.72 5.72a.75.75 0 001.06 0z"></path></svg></div>
</summary><div class="summary-content card-body docutils">
<div class="vimeo docutils container">
<iframe src="https://player.vimeo.com/video/486557682"
frameborder="0" allow="autoplay; fullscreen"
allowfullscreen></iframe></div>
</div>
</details><p>Before we dive into the various different ways that Python code can be
organised and run, it’s helpful to have a mental model of what it
actually means for Python code to execute. Python is an interpreted
language. This means that the program that runs is not made up of the
primitive machine-level instructions that the processor in your
computer executes. Instead, the Python program is read and executed by
another piece of software, the Python interpreter. The Python
interpreter takes a sequence of Python statements and performs the
actions they specify. The Python interpreter takes care of allocating
the required memory and causes the right sequences of primitive
machine-level instructions to execute on the actual hardware for your
programme to run.</p>
<p>The Python interpreter is the same no matter whether you use Jupyter
notebooks, an interactive Python terminal such as IPython, or execute
code written in Python scripts. These are all just different ways of
providing a sequence of Python commands to the interpreter, and
conveying the output back to the user. This means that the same Python
code works in essentially the same way no matter how you use
Python. The Python interpreter also sits between the Python code and
the operating system, so for most purposes, it also doesn’t matter
whether your Python program is running on Windows, macOS, Linux, or
maybe something more exotic. Usually, when we refer to Python doing
something or responding to code in a particular way, what we mean is
that this is what the interpreter does in those circumstances.</p>
</section>
<section id="python-scripts-and-text-editors">
<h2><span class="section-number">2.4. </span>Python scripts and text editors<a class="headerlink" href="#python-scripts-and-text-editors" title="Permalink to this headline">¶</a></h2>
<p>A Python script is simply a plain text file containing Python code. If
we pass the file to the Python interpreter, then all the code in the
file will be executed, it’s that simple. So, we need a way to create
files full of Python code, and a way to feed them to Python. We create
and edit Python files with a program called a text editor. A good text
editor will help you to code by highlighting syntax and helping with
indentation. Some text editors also feature advanced features such as
built-in access to documentation, or highlighting style problems in
your code. A more fully-featured option is an Integrated Development
Environment (IDE). IDEs combine an editor with a Python interpreter to
run your code, a debugger and often other features such as integration
with Git.</p>
<p>During this course, it will be assumed that you’re using the IDE Microsoft
Visual Studio Code. You don’t have to do so, and if you have a strong preference
for another text editor or IDE then you are welcome to use it. That said, if
your text editor does not have a collaborative editing facility equivalent to
Visual Studo Code’s Live Share, then you are likely to need to use Visual Studio
Code when you ask for help so that the helper can share your editor session.</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>Text files</p>
<p>You are doubtless familiar with the concept of a file stored in a folder on
your computer. You will also be aware that there are many different types of
file, more or less related to the type of data they contain and the programs
which created them. Files fall into two important categories, binary files
and text files. A binary file is a stream of data whose contents make
sense under the rules of the application which created it, but not
otherwise. Word documents, PDFs, and JPEGs are examples of binary files.
Plain text files are files which, as the name suggests, consist of a string
of characters. Anyone looking at the content of a text file can
understand it, so long as they understand the human or computer language in
which it is written. LaTeX source files and Python scripts are examples of
text files. This matters when you come to edit these files. Text files are
edited using a text editor, or an IDE. Usually you can use whichever text
editor you like, though some will have better support for writing some
computer languages than others. Importantly, you can’t edit text files in a
program such as Microsoft Word and expect to end up with something usable.</p>
</div>
<section id="a-first-python-script">
<h3><span class="section-number">2.4.1. </span>A first Python script<a class="headerlink" href="#a-first-python-script" title="Permalink to this headline">¶</a></h3>
<p>Tradition dictates that the first stand-alone program one writes in
any language simply prints out the string <code class="xref py py-obj docutils literal notranslate"><span class="pre">Hello</span> <span class="pre">World</span></code>. Using a text
editor, we create a file which we’ll call <code class="file docutils literal notranslate"><span class="pre">hello.py</span></code> containing just
the following line of Python code:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Hello World&quot;</span><span class="p">)</span>
</pre></div>
</div>
<p>The <code class="file docutils literal notranslate"><span class="pre">.py</span></code> file extension is not strictly required for Python scripts,
but it can be useful as it will cause most text editors to recognise
the file as a Python file. Having remembered to save <code class="file docutils literal notranslate"><span class="pre">hello.py</span></code> to
disk from the text editor, we can now run the program. Open a
terminal, and change to the folder (directory) where you saved
<code class="file docutils literal notranslate"><span class="pre">hello.py</span></code>. For example, if <code class="file docutils literal notranslate"><span class="pre">hello.py</span></code> is in the directory <code class="file docutils literal notranslate"><span class="pre">src</span></code> in
your home directory, then on most operating systems, you would type the following:</p>
<div class="highlight-console notranslate"><div class="highlight"><pre><span></span><span class="gp">$ </span><span class="nb">cd</span> src
<span class="gp">$ </span>python3 hello.py
</pre></div>
</div>
<p>on Windows you might instead need to type:</p>
<div class="highlight-console notranslate"><div class="highlight"><pre><span></span><span class="go">&gt; cd src</span>
<span class="go">&gt; py hello.py</span>
</pre></div>
</div>
<p>The dollar sign is the command prompt. Its different on some systems, for
example, it’s often a greater than sign (<code class="xref py py-obj docutils literal notranslate"><span class="pre">&gt;</span></code>). The text to the left of the
command prompt might also be different depending on which terminal program you
are using on which operating system, but we are only concerned with the commands
to the right of the prompt. The first of these, <code class="xref py py-obj docutils literal notranslate"><span class="pre">cd</span></code> (<em>change directory</em>)
switches the current folder to <code class="file docutils literal notranslate"><span class="pre">src</span></code>. The second command actually runs the
Python interpreter on <code class="file docutils literal notranslate"><span class="pre">hello.py</span></code>. Depending on what is installed on your
computer, it might also be possible to leave off the <code class="xref py py-obj docutils literal notranslate"><span class="pre">3</span></code> at the end of
<code class="xref py py-obj docutils literal notranslate"><span class="pre">python3</span></code>, however on some systems the plain <code class="xref py py-obj docutils literal notranslate"><span class="pre">python</span></code> command is still linked to
the old version 2 of Python, so it’s better to be explicit and type <code class="xref py py-obj docutils literal notranslate"><span class="pre">python3</span></code>.
Once we start working with Python <a class="reference internal" href="#term-virtual-environment"><span class="xref std std-term">virtual environments</span></a>, it will always be safe to use <code class="xref py py-obj docutils literal notranslate"><span class="pre">python</span></code> without the 3. When we
press the <kbd class="kbd docutils literal notranslate">enter</kbd> key after the last line above, our tiny Python script
<code class="file docutils literal notranslate"><span class="pre">hello.py</span></code> runs and the following is displayed:</p>
<div class="highlight-console notranslate"><div class="highlight"><pre><span></span><span class="go">Hello World</span>
</pre></div>
</div>
</section>
<section id="when-to-use-scripts">
<h3><span class="section-number">2.4.2. </span>When to use scripts<a class="headerlink" href="#when-to-use-scripts" title="Permalink to this headline">¶</a></h3>
<p>The key advantage of a script is that it is repeatable: it can be
executed again, and exactly the same commands will execute. Writing
scripts is an absolutely essential programming discipline in any
circumstance where you might want to know what you did and, possibly,
do it again. For example, suppose you have a project in a
computational statistics course, in which you need to apply a complex
sequence of operations to a dataset and then plot some resulting
quantities. You could simply do this in an interactive Python session,
but you are then totally dependent on your memory as to what
you did. If you make a mistake, then you <em>might</em> notice an error in the
final result, but you will almost certainly not recall the inadvertent
mistake that led to it.</p>
<p>Conversely, had you written every step you took as a Python script
which outputs the final plot to a pdf for inclusion in your report,
you can go back over your work and find the error. A particularly
frustrating phenomenon, often encountered shortly before a submission
deadline, is to suddenly discover that something which used to work no
longer does. If you took the next logical step and committed your
scripts to a git repository, making a new commit every time you edit
it, you would also be able to go back and find the point at which the
script stopped working. We will return to this debugging technique in
<a class="reference internal" href="9_debugging.html#bisection-debugging"><span class="std std-numref">Section 8.7.2</span></a>.</p>
</section>
<section id="when-not-to-use-scripts">
<h3><span class="section-number">2.4.3. </span>When not to use scripts<a class="headerlink" href="#when-not-to-use-scripts" title="Permalink to this headline">¶</a></h3>
<p>The one thing that scripts can do is run. This makes them an
exceptional tool for reproducing calculations. However, as
mathematicians and programmers, we are also interested in building
tools which users can combine together in different ways. We also want
to make functions and other code objects which can be reused in
different contexts to perform more complex computations. Functions and
other data structures defined in a script can essentially only be used
in that script. As soon as a piece of code is intended to be used in
two different scripts, it should be taken out and placed in a
module. This means that scripts should usually be quite short lists of
calls out to code in modules. We’ll see a simple example of this
shortly.</p>
</section>
</section>
<section id="modules">
<span id="id1"></span><h2><span class="section-number">2.5. </span>Modules<a class="headerlink" href="#modules" title="Permalink to this headline">¶</a></h2>
<details class="sphinx-bs dropdown card mb-3">
<summary class="summary-title card-header">
Video: a first Python module.<div class="summary-down docutils">
<svg version="1.1" width="24" height="24" class="octicon octicon-chevron-down" viewBox="0 0 24 24" aria-hidden="true"><path fill-rule="evenodd" d="M5.22 8.72a.75.75 0 000 1.06l6.25 6.25a.75.75 0 001.06 0l6.25-6.25a.75.75 0 00-1.06-1.06L12 14.44 6.28 8.72a.75.75 0 00-1.06 0z"></path></svg></div>
<div class="summary-up docutils">
<svg version="1.1" width="24" height="24" class="octicon octicon-chevron-up" viewBox="0 0 24 24" aria-hidden="true"><path fill-rule="evenodd" d="M18.78 15.28a.75.75 0 000-1.06l-6.25-6.25a.75.75 0 00-1.06 0l-6.25 6.25a.75.75 0 101.06 1.06L12 9.56l5.72 5.72a.75.75 0 001.06 0z"></path></svg></div>
</summary><div class="summary-content card-body docutils">
<div class="vimeo docutils container">
<iframe src="https://player.vimeo.com/video/486845755"
frameborder="0" allow="autoplay; fullscreen"
allowfullscreen></iframe></div>
</div>
</details><p>A module is, like a script, a plain text file containing Python
code. Modules must have names ending in <code class="file docutils literal notranslate"><span class="pre">.py</span></code>. So far, that’s
identical to a script. Indeed, it’s sometimes possible (though not
always advisable) to use the same file as both a script and a
module. The difference between a script and a module lies in how it is
used. A script is run, which means that a new Python interpreter
starts, executes the commands in the script, and then
exits. Conversely, a module is imported into a running Python
session. For example, suppose we create a file <code class="file docutils literal notranslate"><span class="pre">fibonacci.py</span></code>
containing the following simple function:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">fib</span><span class="p">(</span><span class="n">n</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Return the n-th Fibonacci number.&quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="n">n</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
        <span class="k">return</span> <span class="mi">0</span>
    <span class="k">elif</span> <span class="n">n</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
        <span class="k">return</span> <span class="mi">1</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">fib</span><span class="p">(</span><span class="n">n</span><span class="o">-</span><span class="mi">2</span><span class="p">)</span> <span class="o">+</span> <span class="n">fib</span><span class="p">(</span><span class="n">n</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span>
</pre></div>
</div>
<p>If I now run IPython in the folder containing my new file
<code class="file docutils literal notranslate"><span class="pre">fibonacci.py</span></code> then I will be able to import the <a class="reference internal" href="fibonacci.html#module-fibonacci" title="fibonacci"><code class="xref py py-mod docutils literal notranslate"><span class="pre">fibonacci</span></code></a>
module, and use the function <code class="xref py py-func docutils literal notranslate"><span class="pre">fib()</span></code>:</p>
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="gp">In [1]: </span><span class="kn">import</span> <span class="nn">fibonacci</span>
<span class="gp">In [2]: </span><span class="n">fibonacci</span><span class="o">.</span><span class="n">fib</span><span class="p">(</span><span class="mi">3</span><span class="p">)</span>
<span class="gh">Out[2]: </span><span class="go">2</span>
</pre></div>
</div>
<p>Notice that we do not include the <code class="file docutils literal notranslate"><span class="pre">.py</span></code> suffix when we import a
module. Importing a module provides access to whatever it
contains. This is a key tool in building up algorithms out of
components: we import the components we need at each stage of our
programs.</p>
<section id="importing-and-namespaces">
<h3><span class="section-number">2.5.1. </span>Importing and namespaces<a class="headerlink" href="#importing-and-namespaces" title="Permalink to this headline">¶</a></h3>
<p>When we imported the module <a class="reference internal" href="fibonacci.html#module-fibonacci" title="fibonacci"><code class="xref py py-mod docutils literal notranslate"><span class="pre">fibonacci</span></code></a>, this created the name
<a class="reference internal" href="fibonacci.html#module-fibonacci" title="fibonacci"><code class="xref py py-obj docutils literal notranslate"><span class="pre">fibonacci</span></code></a> in the current environment. The code in <code class="xref py py-obj docutils literal notranslate"><span class="pre">fibonacci.py</span></code> is
then run, and any names defined in that code (such as the function
<code class="xref py py-func docutils literal notranslate"><span class="pre">fib()</span></code>) are defined within the <a class="reference internal" href="#term-namespace"><span class="xref std std-term">namespace</span></a> <a class="reference internal" href="fibonacci.html#module-fibonacci" title="fibonacci"><code class="xref py py-obj docutils literal notranslate"><span class="pre">fibonacci</span></code></a>. As
we begin to compose together code from different parts of mathematics,
the ability to separate identically named but different objects from
each other is essential. For example, Python has a module containing
core real-valued maths functions called <a class="reference external" href="https://docs.python.org/3/library/math.html#module-math" title="(in Python v3.10)"><code class="docutils literal notranslate"><span class="pre">math</span></code></a>, and one
containing complex maths functions called
<a class="reference external" href="https://docs.python.org/3/library/cmath.html#module-cmath" title="(in Python v3.10)"><code class="docutils literal notranslate"><span class="pre">cmath</span></code></a>. Clearly, it’s important that we can distinguish
between <a class="reference external" href="https://docs.python.org/3/library/math.html#math.sin" title="(in Python v3.10)"><code class="docutils literal notranslate"><span class="pre">math.sin()</span></code></a> and <a class="reference external" href="https://docs.python.org/3/library/cmath.html#cmath.sin" title="(in Python v3.10)"><code class="docutils literal notranslate"><span class="pre">cmath.sin()</span></code></a>. Here the
module names <a class="reference external" href="https://docs.python.org/3/library/math.html#module-math" title="(in Python v3.10)"><code class="xref py py-mod docutils literal notranslate"><span class="pre">math</span></code></a> and <a class="reference external" href="https://docs.python.org/3/library/cmath.html#module-cmath" title="(in Python v3.10)"><code class="xref py py-mod docutils literal notranslate"><span class="pre">cmath</span></code></a> form the namespaces that
differentiate between the two <code class="xref py py-func docutils literal notranslate"><span class="pre">sin()</span></code> functions. There are
essentially only two core namespace concepts. One of them is that
every name is in a namespace, and any given time points to a unique
value. The second one is that namespaces can be nested, so a name in a
namespace can itself be another namespace. For example, the math
namespace contains the value <a class="reference external" href="https://docs.python.org/3/library/math.html#math.pi" title="(in Python v3.10)"><code class="xref py py-obj docutils literal notranslate"><span class="pre">math.pi</span></code></a>, which itself defines a
namespace for some operations that are built into Python numbers. The
(somewhat uninteresting) imaginary part of π can be accessed as
<code class="xref py py-obj docutils literal notranslate"><span class="pre">math.pi.imag</span></code>.</p>
<p>Namespaces are a simple but fundamental concept in programming. To
quote one of the key developers of the Python language:</p>
<blockquote>
<div><p>Namespaces are one honking great idea – let’s do more of those! <a class="footnote-reference brackets" href="#peters" id="id2">1</a></p>
</div></blockquote>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p><a class="reference internal" href="#term-namespace"><span class="xref std std-term">Namespaces</span></a> may look unfamiliar at first, but
actually, they are such a natural concept that you have been working
with them for as long as you have used a computer, without even
thinking about it. This is because folders are simply namespaces
for files. Each filename can exist only once in each folder, and
you can nest folders inside folders.</p>
</div>
</section>
<section id="other-forms-of-import">
<h3><span class="section-number">2.5.2. </span>Other forms of import<a class="headerlink" href="#other-forms-of-import" title="Permalink to this headline">¶</a></h3>
<p>Importing modules into their own namespaces is frequently what we
want: it clearly separates the names in the module from the names we
have defined ourselves, and makes it very obvious to a reader where
the names come from. The downside is that names in namespaces can be
quite long and cumbersome, which is particularly inconvenient if names
are to be used frequently or in the middle of formulae: you probably
don’t really want to write <a class="reference external" href="https://docs.python.org/3/library/math.html#math.sin" title="(in Python v3.10)"><code class="xref py py-func docutils literal notranslate"><span class="pre">math.sin()</span></code></a> in every trig formula you
ever write. One alternative is to rename the module on import. This is
achieved using the keyword <a class="reference external" href="https://docs.python.org/3/reference/simple_stmts.html#import" title="(in Python v3.10)"><code class="xref std std-keyword docutils literal notranslate"><span class="pre">as</span></code></a> in an import statement. For example,
it is usual to import the numerical Python module <a class="reference external" href="https://numpy.org/doc/stable/reference/index.html#module-numpy" title="(in NumPy v1.22)"><code class="xref py py-mod docutils literal notranslate"><span class="pre">numpy</span></code></a> in the
following way:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>
</pre></div>
</div>
<p>This creates the local name <a class="reference external" href="https://numpy.org/doc/stable/reference/index.html#module-numpy" title="(in NumPy v1.22)"><code class="xref py py-mod docutils literal notranslate"><span class="pre">np</span></code></a> instead of <a class="reference external" href="https://numpy.org/doc/stable/reference/index.html#module-numpy" title="(in NumPy v1.22)"><code class="xref py py-mod docutils literal notranslate"><span class="pre">numpy</span></code></a>,
so that the function for creating an evenly spaced sequence of values
between to end points is now accessible as <a class="reference external" href="https://numpy.org/doc/stable/reference/generated/numpy.linspace.html#numpy.linspace" title="(in NumPy v1.22)"><code class="xref py py-func docutils literal notranslate"><span class="pre">np.linspace</span></code></a>.</p>
<p>A second option is to import particular names from a module directly
into the current namespace. For example, if we planned to use the
functions <a class="reference external" href="https://docs.python.org/3/library/math.html#math.sin" title="(in Python v3.10)"><code class="xref py py-func docutils literal notranslate"><span class="pre">math.sin()</span></code></a> and <a class="reference external" href="https://docs.python.org/3/library/math.html#math.cos" title="(in Python v3.10)"><code class="xref py py-func docutils literal notranslate"><span class="pre">math.cos()</span></code></a> a lot in our script, we
might use the following import statement:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">math</span> <span class="kn">import</span> <span class="n">sin</span><span class="p">,</span> <span class="n">cos</span>
</pre></div>
</div>
<p>Now we can use the names <a class="reference external" href="https://docs.python.org/3/library/math.html#math.sin" title="(in Python v3.10)"><code class="xref py py-func docutils literal notranslate"><span class="pre">sin</span></code></a> and <a class="reference external" href="https://docs.python.org/3/library/math.html#math.cos" title="(in Python v3.10)"><code class="xref py py-func docutils literal notranslate"><span class="pre">cos</span></code></a> directly. What if we also wanted to use a short name for
their complex counterparts? We can’t have two functions with the same
name in a single <a class="reference internal" href="#term-namespace"><span class="xref std std-term">namespace</span></a>. Fortunately, the keyword <code class="xref py py-obj docutils literal notranslate"><span class="pre">as</span></code>
comes to our rescue again:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">cmath</span> <span class="kn">import</span> <span class="n">sin</span> <span class="k">as</span> <span class="n">csin</span><span class="p">,</span> <span class="n">cos</span> <span class="k">as</span> <span class="n">ccos</span>
</pre></div>
</div>
<p>Renaming on import is a double-edged sword. You must always take care
that renaming does not add to the confusion. As a somewhat extreme
example, should you ever type the following code, you should expect
the wrath of your users to be without bounds:</p>
<div class="badcode docutils container">
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">math</span> <span class="kn">import</span> <span class="n">sin</span> <span class="k">as</span> <span class="n">cos</span><span class="p">,</span> <span class="n">cos</span> <span class="k">as</span> <span class="n">sin</span>
</pre></div>
</div>
</div>
<p>It is possible to import all of the names from a module into the current namespace:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">math</span> <span class="kn">import</span> <span class="o">*</span>
</pre></div>
</div>
<p>Now everything in the math module can be used without a namespace
prefix. This may seem superficially attractive, but actually importing
<code class="xref py py-obj docutils literal notranslate"><span class="pre">*</span></code> is a frequent source of problems. For starters, if you import <code class="xref py py-obj docutils literal notranslate"><span class="pre">*</span></code>
from more than one module, it becomes impossible for the reader of the
code to work out from which module each name comes. Further, if a
module from which you import <code class="xref py py-obj docutils literal notranslate"><span class="pre">*</span></code> contains a name that you have already
used, then the meaning of that name will be overwritten with the one
from the module (without any warning or error). This is a frequent
source of confusion. For this reason, importing <code class="xref py py-obj docutils literal notranslate"><span class="pre">*</span></code> is usually a bad
idea.</p>
<p>The full details of all the ways that the import statement can be used
is in <a class="reference external" href="https://docs.python.org/3/reference/simple_stmts.html#import" title="(in Python v3.10)"><span class="xref std std-ref">the official Python documentation.</span></a></p>
</section>
</section>
<section id="packages">
<h2><span class="section-number">2.6. </span>Packages<a class="headerlink" href="#packages" title="Permalink to this headline">¶</a></h2>
<details class="sphinx-bs dropdown card mb-3">
<summary class="summary-title card-header">
Video: a first Python package.<div class="summary-down docutils">
<svg version="1.1" width="24" height="24" class="octicon octicon-chevron-down" viewBox="0 0 24 24" aria-hidden="true"><path fill-rule="evenodd" d="M5.22 8.72a.75.75 0 000 1.06l6.25 6.25a.75.75 0 001.06 0l6.25-6.25a.75.75 0 00-1.06-1.06L12 14.44 6.28 8.72a.75.75 0 00-1.06 0z"></path></svg></div>
<div class="summary-up docutils">
<svg version="1.1" width="24" height="24" class="octicon octicon-chevron-up" viewBox="0 0 24 24" aria-hidden="true"><path fill-rule="evenodd" d="M18.78 15.28a.75.75 0 000-1.06l-6.25-6.25a.75.75 0 00-1.06 0l-6.25 6.25a.75.75 0 101.06 1.06L12 9.56l5.72 5.72a.75.75 0 001.06 0z"></path></svg></div>
</summary><div class="summary-content card-body docutils">
<div class="vimeo docutils container">
<iframe src="https://player.vimeo.com/video/487003753"
frameborder="0" allow="autoplay; fullscreen"
allowfullscreen></iframe></div>
</div>
</details><p>Modules are the principal mechanism for storing code which is intended
to be used by other code. However, putting all of the code for a
complex area of mathematics in a single huge Python file is not a
great idea. Readers of that code will struggle to see the logical
structure of thousands or tens of thousands of lines of code. It would
be much more logical, and much easier to work with, to split the code
up into several files of more reasonable length. This is where
packages come in. A Python package is a collection of module files,
which can be imported together. The basic folder structure of a Python
package looks like the following:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>my_git_repo
├── my_package
│   ├── __init__.py
│   ├── module_1.py
│   ├── module_2.py
│   └── subpackage
│       ├── __init__.py
│       └── module_3.py
└── setup.py
</pre></div>
</div>
<p>If you haven’t seen a diagram like this before, the names with lines
descending from their first letter are folder names, and the
descending line connects the folder name to the files and folders it
contains. Let’s walk through these files and folders to understand how
they make up the Python package.</p>
<dl>
<dt><code class="file docutils literal notranslate"><span class="pre">my_git_repo</span></code></dt><dd><p>This is not really a part of the package at all, but the
<code class="file docutils literal notranslate"><span class="pre">my_package</span></code> folder needs to be in some folder, and this is a
reminder that all your work should be in a revision control system
such as <a class="reference external" href="https://imperial-fons-computing.github.io/git.html#git" title="(in Installation instructions for FoNS v2020.0)"><span class="xref std std-ref">git</span></a>. It would be usual for
package folders to be contained immediately in the top level of
the repository, in the manner shown here.</p>
</dd>
<dt><code class="file docutils literal notranslate"><span class="pre">my_package</span></code></dt><dd><p>This is the actual package. The name of this folder sets the
package name, so if you really made a package folder with this
name, then you would type:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="kn">import</span> <span class="nn">my_package</span>
</pre></div>
</div>
<p>to access the package.</p>
</dd>
<dt><code class="file docutils literal notranslate"><span class="pre">__init__.py</span></code></dt><dd><p>Every package must contain a file with <em>exactly</em> this name. This is
how Python recognises that a folder is a package. <code class="file docutils literal notranslate"><span class="pre">__init__.py</span></code>
can be an empty file, or it can contain code to populate the top
level <a class="reference internal" href="#term-namespace"><span class="xref std std-term">namespace</span></a> of the package. See <a class="reference internal" href="#importing-packages"><span class="std std-numref">Section 2.6.1</span></a> below.</p>
</dd>
<dt><code class="file docutils literal notranslate"><span class="pre">module_1.py</span></code>, <code class="file docutils literal notranslate"><span class="pre">module_2.py</span></code></dt><dd><p>These are just Python <a class="reference internal" href="#term-module"><span class="xref std std-term">modules</span></a>. If the user imports
<code class="xref py py-obj docutils literal notranslate"><span class="pre">my_package</span></code> using the line above then these modules will appear
as <code class="xref py py-obj docutils literal notranslate"><span class="pre">my_package.module_1</span></code> and <code class="xref py py-obj docutils literal notranslate"><span class="pre">my_package.module_2</span></code> respectively.</p>
</dd>
<dt><code class="file docutils literal notranslate"><span class="pre">subpackage</span></code></dt><dd><p>Packages can contain packages. A subpackage is just a folder
containing a file <code class="file docutils literal notranslate"><span class="pre">__init__.py</span></code>. It can also contain modules and
further subpackages.</p>
</dd>
<dt><code class="file docutils literal notranslate"><span class="pre">setup.py</span></code></dt><dd><p>This file is outside the package folder and is not
actually a part of the package. The role of <code class="file docutils literal notranslate"><span class="pre">setup.py</span></code> will be
covered in <a class="reference internal" href="#installable-packages"><span class="std std-numref">Section 2.6.2</span></a>.</p>
</dd>
</dl>
<section id="importing-packages">
<span id="id3"></span><h3><span class="section-number">2.6.1. </span>Importing packages<a class="headerlink" href="#importing-packages" title="Permalink to this headline">¶</a></h3>
<p>The system for importing packages is the same as that described in
<a class="reference internal" href="#modules"><span class="std std-numref">Section 2.5</span></a>, though the nested nature of packages makes the
process somewhat more involved. Importing a package also imports all
the modules it contains, including those in subpackages. This will
establish a set of nested namespaces. In the example above, after
importing <code class="xref py py-mod docutils literal notranslate"><span class="pre">my_package</span></code>, <code class="xref py py-mod docutils literal notranslate"><span class="pre">module_3</span></code> will be accessible as
<code class="xref py py-obj docutils literal notranslate"><span class="pre">my_package.subpackage.module_3</span></code>. The usual rules about the <code class="xref py py-obj docutils literal notranslate"><span class="pre">from</span></code>
keyword still apply, so:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">my_package.subpackages</span> <span class="kn">import</span> <span class="n">module_3</span>
</pre></div>
</div>
<p>would import the name <code class="xref py py-obj docutils literal notranslate"><span class="pre">module_3</span></code> straight into the current local
namespace.</p>
<p>The file <code class="file docutils literal notranslate"><span class="pre">__init__.py</span></code> is itself a module and will be imported when
the package is imported. However, names defined in <code class="file docutils literal notranslate"><span class="pre">__init__.py</span></code> will
appear directly in the namespace of the package. This is usually used
to extract names from submodules that are supposed to be directly
accessed by users of the package.</p>
<p>For example, suppose that <code class="xref py py-obj docutils literal notranslate"><span class="pre">module_1</span></code> contains a function
<code class="xref py py-obj docutils literal notranslate"><span class="pre">my_func</span></code>. Then the top level <code class="file docutils literal notranslate"><span class="pre">__init__.py</span></code> in <code class="xref py py-obj docutils literal notranslate"><span class="pre">my_package</span></code> might contain
the line:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">.module_1</span> <span class="kn">import</span> <span class="n">my_func</span>
</pre></div>
</div>
<p>The result of this would be that the user of <code class="xref py py-obj docutils literal notranslate"><span class="pre">my_package</span></code> would be
able to access <code class="xref py py-obj docutils literal notranslate"><span class="pre">my_func</span></code> as <code class="xref py py-obj docutils literal notranslate"><span class="pre">my_package.my_func</span></code> (though
<code class="xref py py-obj docutils literal notranslate"><span class="pre">my_package.module_1.my_func</span></code> would also work). This sort of
arrangement provides a mechanism for the programmer to arrange the
internal module structure of a package in a logical way while still
providing users with direct access to the most important or most
frequently used features.</p>
<p>The eagle-eyed reader will have noticed the extra . in front of
<code class="xref py py-obj docutils literal notranslate"><span class="pre">module_1</span></code>. This marks this import as a <em>relative import</em>. In other
words, in looking for <code class="file docutils literal notranslate"><span class="pre">module_1.py</span></code>, Python should look for files in
the same folder as the module where the import statement occurs,
instead of looking for an external package called <code class="xref py py-obj docutils literal notranslate"><span class="pre">module_1</span></code>. We could
have equivalently written:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">my_package.module_1</span> <span class="kn">import</span> <span class="n">my_func</span>
</pre></div>
</div>
<p>but the relative import is shorter and provides a reminder to the
reader that the import is from the current package.</p>
</section>
<section id="making-packages-installable">
<span id="installable-packages"></span><h3><span class="section-number">2.6.2. </span>Making packages installable<a class="headerlink" href="#making-packages-installable" title="Permalink to this headline">¶</a></h3>
<p>In order for the <a class="reference external" href="https://docs.python.org/3/reference/simple_stmts.html#import" title="(in Python v3.10)"><span class="xref std std-ref">import statement</span></a> to work, Python needs
to know that the package being imported exists, and where to find it. This is
achieved by <em>installing</em> the package. In order to make a package installable, we
need to provide Python with a bit more information about it. This
information is contained in a Python script which must be called <code class="file docutils literal notranslate"><span class="pre">setup.py</span></code>.
This file isn’t part of the package and does not go in the package folder.
Instead, it should be placed in the top-level folder of your git repository, so
that the Python package installer will be able to find it.</p>
<p>At the very least, <code class="file docutils literal notranslate"><span class="pre">setup.py</span></code> should contain the following:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">setuptools</span> <span class="kn">import</span> <span class="n">setup</span><span class="p">,</span> <span class="n">find_packages</span>
<span class="n">setup</span><span class="p">(</span>
    <span class="n">name</span><span class="o">=</span><span class="s2">&quot;my_package&quot;</span><span class="p">,</span>
    <span class="n">version</span><span class="o">=</span><span class="s2">&quot;0.1&quot;</span><span class="p">,</span>
    <span class="n">packages</span><span class="o">=</span><span class="n">find_packages</span><span class="p">(),</span>
<span class="p">)</span>
</pre></div>
</div>
<p><a class="reference external" href="https://setuptools.readthedocs.io/en/latest/index.html">Setuptools</a>
is a Python package which exists to help with the packaging and
installation of Python packages. The <code class="xref py py-func docutils literal notranslate"><span class="pre">setup()</span></code>
function records metadata such as the installation name to be given to
your whole set of packages, and the version. It also needs to know
about all of the packages in the current repository, but this can be
automated with the <code class="xref py py-func docutils literal notranslate"><span class="pre">find_packages()</span></code> function, which
will return a list of folders containing a file named <code class="file docutils literal notranslate"><span class="pre">__init__.py</span></code>.</p>
<p>This very simple <code class="file docutils literal notranslate"><span class="pre">setup.py</span></code> will suffice for packages that you only
intend to use yourself. Should you wish to publish packages for use by
other people, then you’ll need to add some more information to the
file. The canonical guide to this is the <a class="reference external" href="https://packaging.python.org/tutorials/packaging-projects/">Python packaging user guide</a>.</p>
</section>
<section id="installing-a-package-from-local-code">
<h3><span class="section-number">2.6.3. </span>Installing a package from local code<a class="headerlink" href="#installing-a-package-from-local-code" title="Permalink to this headline">¶</a></h3>
<p>Another important case is where the Python package exists in files
(hopefully a git repository!) on your local computer. This is usually
the case where you are developing the package yourself. In this case,
you would type:</p>
<div class="highlight-console notranslate"><div class="highlight"><pre><span></span><span class="gp gp-VirtualEnv">(my_venv)</span> <span class="gp">$ </span>python -m pip install -e folder/
</pre></div>
</div>
<p>replacing <code class="xref py py-obj docutils literal notranslate"><span class="pre">folder</span></code> with the name of the top-level folder of your
repository: the folder containing <code class="file docutils literal notranslate"><span class="pre">setup.py</span></code>. The option flag <code class="xref py py-obj docutils literal notranslate"><span class="pre">-e</span></code>
tells pip to install the package in ‘editable’ mode. This means that
instead of copying the package files to your venv’s Python packages
folder, symbolic links will be created. This means that any changes
that you make to your package will show up the next time the package
is imported in a new Python process, avoiding the need to reinstall
the package every time you change it.</p>
<div class="admonition warning">
<p class="admonition-title">Warning</p>
<p>If you edit a package, even one installed in editable mode, an
already running Python process which has already imported that
package will not notice the change. This is a common cause of
confusion for users who are editing packages and testing them using
an interactive Python tool such as IPython or a Jupyter Notebook. A
major advantage of a Python script is that a new Python process is
started every time the script is run, so the packages used are
guaranteed to be up to date.</p>
</div>
</section>
</section>
<section id="testing-frameworks">
<h2><span class="section-number">2.7. </span>Testing frameworks<a class="headerlink" href="#testing-frameworks" title="Permalink to this headline">¶</a></h2>
<details class="sphinx-bs dropdown card mb-3">
<summary class="summary-title card-header">
Video: introducing Pytest.<div class="summary-down docutils">
<svg version="1.1" width="24" height="24" class="octicon octicon-chevron-down" viewBox="0 0 24 24" aria-hidden="true"><path fill-rule="evenodd" d="M5.22 8.72a.75.75 0 000 1.06l6.25 6.25a.75.75 0 001.06 0l6.25-6.25a.75.75 0 00-1.06-1.06L12 14.44 6.28 8.72a.75.75 0 00-1.06 0z"></path></svg></div>
<div class="summary-up docutils">
<svg version="1.1" width="24" height="24" class="octicon octicon-chevron-up" viewBox="0 0 24 24" aria-hidden="true"><path fill-rule="evenodd" d="M18.78 15.28a.75.75 0 000-1.06l-6.25-6.25a.75.75 0 00-1.06 0l-6.25 6.25a.75.75 0 101.06 1.06L12 9.56l5.72 5.72a.75.75 0 001.06 0z"></path></svg></div>
</summary><div class="summary-content card-body docutils">
<div class="vimeo docutils container">
<iframe src="https://player.vimeo.com/video/486987209"
frameborder="0" allow="autoplay; fullscreen"
allowfullscreen></iframe></div>
</div>
</details><p>Attempting to establish whether a program correctly implements the
intended algorithm is core to effective programming, and programmers
often spend more time correcting bugs than writing new code. We will
turn to the question of how to debug in <a class="reference internal" href="9_debugging.html#debugging"><span class="std std-numref">Section 8</span></a>. However,
right from the start, we need to test the code we write, so we will cover
the practical details of including tests in your code here.</p>
<p>There are a number of Python packages which support code testing. The
concepts are largely similar so rather than get bogged down in the
details of multiple frameworks, we will introduce <a class="reference external" href="https://docs.pytest.org/en/latest/index.html" title="(in pytest v7.2.0.dev79+geb8b3ad92)"><span class="xref std std-doc">pytest</span></a>, which is one of the most widely used. Pytest is simply a Python
package, so you can install it into your current environment using:</p>
<div class="highlight-console notranslate"><div class="highlight"><pre><span></span><span class="gp">$ </span>python -m pip install pytest
</pre></div>
</div>
<section id="pytest-tests">
<h3><span class="section-number">2.7.1. </span>Pytest tests<a class="headerlink" href="#pytest-tests" title="Permalink to this headline">¶</a></h3>
<p>A Pytest test is simply a function whose name starts with <code class="xref py py-obj docutils literal notranslate"><span class="pre">test_</span></code>. In
the simplest case, the function has no arguments. Pytest will call each
such function in turn. If the function executes without error, then the
test is taken to have passed, while if an error occurs then the test
has failed. This behaviour might at first seem surprising - we don’t
just want the code to run, it has to get the right answer. However,
thinking about it the other way around, we certainly want the test to
fail if an error occurs. It’s also very easy to arrange things such
that an error occurs when the wrong answer is reached. This is most
readily achieved using <a class="reference external" href="https://docs.python.org/3/reference/simple_stmts.html#assert" title="(in Python v3.10)"><span class="xref std std-ref">the assert statement</span></a>.
This simply consists of <code class="xref py py-obj docutils literal notranslate"><span class="pre">assert</span></code> followed
by a Python expression. If the expression is true, then execution just
continues, but if it’s false, then an error occurs. For example:</p>
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="gp">In [1]: </span><span class="k">assert</span> <span class="mi">1</span> <span class="o">==</span> <span class="mi">0</span>
<span class="gt">---------------------------------------------------------------------------</span>
<span class="ne">AssertionError</span><span class="g g-Whitespace">                            </span>Traceback (most recent call last)
<span class="o">&lt;</span><span class="n">ipython</span><span class="o">-</span><span class="nb">input</span><span class="o">-</span><span class="mi">1</span><span class="o">-</span><span class="n">e99f91a18d62</span><span class="o">&gt;</span> <span class="ow">in</span> <span class="o">&lt;</span><span class="n">module</span><span class="o">&gt;</span>
<span class="ne">----&gt; </span><span class="mi">1</span> <span class="k">assert</span> <span class="mi">1</span> <span class="o">==</span> <span class="mi">0</span>

<span class="ne">AssertionError</span>:
</pre></div>
</div>
</section>
<section id="pytest-files">
<h3><span class="section-number">2.7.2. </span>Pytest files<a class="headerlink" href="#pytest-files" title="Permalink to this headline">¶</a></h3>
<p>Pytest looks for tests in files whose name starts with <code class="file docutils literal notranslate"><span class="pre">test_</span></code> and
ends with <code class="file docutils literal notranslate"><span class="pre">.py</span></code>. Continuing with our Fibonacci example, we might
create a file called <code class="file docutils literal notranslate"><span class="pre">test_fibonacci.py</span></code> containing:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">fibonacci</span> <span class="kn">import</span> <span class="n">fib</span>

<span class="k">def</span> <span class="nf">test_fibonacci_values</span><span class="p">():</span>

    <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">f</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">5</span><span class="p">,</span> <span class="mi">8</span><span class="p">]):</span>
        <span class="k">assert</span> <span class="n">fib</span><span class="p">(</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span> <span class="o">==</span> <span class="n">f</span>
</pre></div>
</div>
<p>These files don’t themselves form part of the package, instead they
are usually gathered in a separate tests folder. For example:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>fibonacci
├── fibonacci
│   ├── __init__.py
│   └── fibonacci.py
├── tests
│   └── test_fibonacci.py
└── setup.py
</pre></div>
</div>
<p>We can then invoke the tests from the shell:</p>
<div class="highlight-console notranslate"><div class="highlight"><pre><span></span><span class="gp">$ </span><span class="nb">cd</span> fibonacci
<span class="gp">$ </span>pytest tests
<span class="go">========================== test session starts ===========================</span>
<span class="go">platform darwin -- Python 3.7.7, pytest-5.4.1, py-1.8.1, pluggy-0.13.1</span>
<span class="go">rootdir: /Users/dham/docs/object-oriented-programming, inifile: setup.cfg</span>
<span class="go">collected 1 item</span>

<span class="go"> .                                          [100%]</span>

<span class="go">=========================== 1 passed in 0.01s ============================</span>
</pre></div>
</div>
<p>The single dot indicates that we passed the one test in
<code class="xref py py-obj docutils literal notranslate"><span class="pre">test_fibonacci.py</span></code>. Had we made an error in our code, we would
instead see something like:</p>
<div class="highlight-console notranslate"><div class="highlight"><pre><span></span><span class="gp">$ </span>pytest tests
<span class="go">========================== test session starts ===========================</span>
<span class="go">platform darwin -- Python 3.7.7, pytest-5.4.1, py-1.8.1, pluggy-0.13.1</span>
<span class="go">rootdir: /Users/dham/docs/object-oriented-programming, inifile: setup.cfg</span>
<span class="go">collected 1 item</span>

<span class="go">tests/test_fibonacci.py F                                          [100%]</span>

<span class="go">================================ FAILURES ================================</span>
<span class="go">_________________________ test_fibonacci_values __________________________</span>

<span class="go">    def test_fibonacci_values():</span>

<span class="go">        for i, f in enumerate([1, 1, 2, 3, 5, 8]):</span>
<span class="go">&gt;           assert fib(i+1) == f</span>
<span class="go">E           assert 2 == 1</span>
<span class="go">E            +  where 2 = fib((1 + 1))</span>

<span class="go">tests/test_fibonacci.py:6: AssertionError</span>
<span class="go">======================== short test summary info =========================</span>
<span class="go">FAILED tests/test_fibonacci.py::test_fibonacci_values - assert 2 == 1</span>
<span class="go">=========================== 1 failed in 0.12s ============================</span>
</pre></div>
</div>
<p>Here we can see an <code class="xref py py-obj docutils literal notranslate"><span class="pre">F</span></code> after <code class="xref py py-obj docutils literal notranslate"><span class="pre">tests/test_fibonacci.py</span></code> indicating
that the test failed, and we see some output detailing what went
wrong. We will learn how to interpret this output in <a class="reference internal" href="9_debugging.html#debugging"><span class="std std-numref">Section 8</span></a>.</p>
</section>
<section id="additional-useful-pytest-tricks">
<h3><span class="section-number">2.7.3. </span>Additional useful pytest tricks<a class="headerlink" href="#additional-useful-pytest-tricks" title="Permalink to this headline">¶</a></h3>
<p>It can be useful to run a specific test file, which is achieved simply by naming
that file as the argument to pytest. For example:</p>
<div class="highlight-console notranslate"><div class="highlight"><pre><span></span><span class="gp">$ </span>pytest tests/test_fibonacci.py
</pre></div>
</div>
<p>It is even possible to select an individual test to run, using a double colon
<code class="xref py py-obj docutils literal notranslate"><span class="pre">::</span></code> followed by the test name:</p>
<div class="highlight-console notranslate"><div class="highlight"><pre><span></span><span class="gp">$ </span>pytest tests/test_fibonacci.py::test_fibonacci_values
</pre></div>
</div>
<p>Often if one test fails then the same problem in your code will cause a whole
series of tests to fail, resulting in a very long list of error messages which
is hard to read. A useful tool in this circumstance is the <code class="xref py py-obj docutils literal notranslate"><span class="pre">-x</span></code> option, which
tells pytest to stop after the first test fail. For example:</p>
<div class="highlight-console notranslate"><div class="highlight"><pre><span></span><span class="gp">$ </span>pytest -x tests
</pre></div>
</div>
<p>The tests are usually arranged in increasing order of sophistication, so the
earlier tests are likely to catch the most basic errors in your code. For this
reason, it is usually the best policy to try to fix the first error first, and
only move onto the next problem when the previous test passes.</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>The exercise repositories in this course will usually contain a
<code class="file docutils literal notranslate"><span class="pre">tests</span></code> folder full of tests that check that you have correctly
implemented the week’s exercises. You should get in the habit of running the
tests as you work through the exercises, as they are designed not just to
pass if your code is correct, but to provide feedback as to what might be
going wrong if your code contains errors.</p>
</div>
</section>
</section>
<section id="writing-code-to-a-specified-interface">
<h2><span class="section-number">2.8. </span>Writing code to a specified interface<a class="headerlink" href="#writing-code-to-a-specified-interface" title="Permalink to this headline">¶</a></h2>
<p>Creating more capable programmes depends completely on being able to interface
different pieces of code. You will write code which calls code written by other
people, and others will call code written by you. This can only work if the
caller and the callee agree exactly on the interface: what are the names of the
<a class="reference internal" href="#term-package"><span class="xref std std-term">packages</span></a>, <a class="reference internal" href="#term-module"><span class="xref std std-term">modules</span></a> and functions being
called. How many arguments do they take? What are the names of the
<a class="reference external" href="https://docs.python.org/3/glossary.html#term-parameter" title="(in Python v3.10)"><span class="xref std std-term">keyword parameters</span></a>? Computer languages are notoriously pedantic about such
things: they have no capability to simply read through small differences as a
human would. You have doubtless already encountered the frustrating situation of
spending extended periods repeatedly getting errors until you realised that
something has to be spelt slightly differently, or that you used a capital
letter where you should have used a lower case one.</p>
<p>What changes as you move on to write code which will be called by other code is
that this need for precision and pedantry now flows in both directions. Not only
do you need to call other code using precisely the correct interface, you also
need to provide precisely the correct interface to the code that will call you.
This will be the case all the way through this course as the tests for each
exercise will call your code. The exercises will specify what the correct
interface is, either in the exercise question itself, or through the skeleton
code which is provided.</p>
<p>Your code needs to follow exactly the specification in the exercise: all the
right names, accepting arguments of the correct type and so on. If it does not,
then the tests will simply fail. Changing the tests to suit your preferred
interface is not an acceptable answer, your code needs to comply with the
interface specified in the tests <a class="footnote-reference brackets" href="#interface-errors" id="id4">2</a>.</p>
<p>This requirement to code to a published specification is not an artifact of the
testing framework: it is often the case that code written in a research or
business setting needs to conform with a standard or other published interface
exactly to create the sort of interoperability we’ve been discussing. Learning
to code to specification is therefore an important programming skill.</p>
</section>
<section id="glossary">
<h2><span class="section-number">2.9. </span>Glossary<a class="headerlink" href="#glossary" title="Permalink to this headline">¶</a></h2>
<blockquote>
<div><dl class="glossary simple">
<dt id="term-module">module<a class="headerlink" href="#term-module" title="Permalink to this term">¶</a></dt><dd><p>A text file containing Python code which is accessed using the <a class="reference external" href="https://docs.python.org/3/reference/simple_stmts.html#import" title="(in Python v3.10)"><span class="xref std std-ref">import statement</span></a>.</p>
</dd>
<dt id="term-namespace">namespace<a class="headerlink" href="#term-namespace" title="Permalink to this term">¶</a></dt><dd><p>A collection of names. Within a single namespace, each
name has a single defined meaning. Names in different spaces
can be referred to using the syntax <code class="xref py py-obj docutils literal notranslate"><span class="pre">namespace.name</span></code> where
<code class="xref py py-obj docutils literal notranslate"><span class="pre">namespace</span></code> is an name for the namespace. namespaces are
themselves named, so they can be nested (<code class="xref py py-obj docutils literal notranslate"><span class="pre">namespace.inner_namespace.name</span></code>).</p>
</dd>
<dt id="term-package">package<a class="headerlink" href="#term-package" title="Permalink to this term">¶</a></dt><dd><p>A grouping of related <a class="reference internal" href="#term-module"><span class="xref std std-term">modules</span></a> into a single importable unit.</p>
</dd>
<dt id="term-Python-interpreter">Python interpreter<a class="headerlink" href="#term-Python-interpreter" title="Permalink to this term">¶</a></dt><dd><p>The piece of software which interprets and executes Python commands.</p>
</dd>
<dt id="term-scope">scope<a class="headerlink" href="#term-scope" title="Permalink to this term">¶</a></dt><dd><p>The scope of a name is the section of code for which that name is valid.</p>
</dd>
<dt id="term-script">script<a class="headerlink" href="#term-script" title="Permalink to this term">¶</a></dt><dt id="term-program">program<a class="headerlink" href="#term-program" title="Permalink to this term">¶</a></dt><dd><p>A text file containing a sequence of Python statements to be
executed. In Python, program and script are synonymous.</p>
</dd>
<dt id="term-venv">venv<a class="headerlink" href="#term-venv" title="Permalink to this term">¶</a></dt><dt id="term-virtual-environment">virtual environment<a class="headerlink" href="#term-virtual-environment" title="Permalink to this term">¶</a></dt><dd><p>A lightweight private Python installation with its own set of
Python packages installed.</p>
</dd>
</dl>
</div></blockquote>
</section>
<section id="exercises">
<h2><span class="section-number">2.10. </span>Exercises<a class="headerlink" href="#exercises" title="Permalink to this headline">¶</a></h2>
<div class="proof proof-type-exercise" id="id5">

    <div class="proof-title">
        <span class="proof-type">Exercise 2.1</span>
        
    </div><div class="proof-content">
<p>Follow the <a class="reference external" href="https://imperial-fons-computing.github.io/python.html#python-folders" title="(in Installation instructions for FoNS v2020.0)"><span class="xref std std-ref">instructions on the Imperial College London Python
installation page</span></a> to create the folder structure
you will use for this course on your computer. Start with an overall folder
for the module, and create a virtual environment in that module.</p>
</div></div><div class="proof proof-type-exercise" id="id6">
<span id="course-repo"></span>
    <div class="proof-title">
        <span class="proof-type">Exercise 2.2</span>
        
    </div><div class="proof-content">
<p>Visit the <a class="reference external" href="https://github.com/object-oriented-python/object-oriented-programming">GitHub repository for these notes</a>.
Clone that git repository into your course folder, and install the Python
package it contains into your virtual environment. Check that it has
installed correctly by installing pytest, and running:</p>
<div class="highlight-console notranslate"><div class="highlight"><pre><span></span><span class="gp">$ </span>pytest tests/test_fibonacci.py
</pre></div>
</div>
<p>You could also run iPython,  import <a class="reference internal" href="fibonacci.html#module-fibonacci" title="fibonacci"><code class="xref py py-mod docutils literal notranslate"><span class="pre">fibonacci</span></code></a> and try out
<a class="reference internal" href="fibonacci.html#fibonacci.fibonacci.fib" title="fibonacci.fibonacci.fib"><code class="xref py py-func docutils literal notranslate"><span class="pre">fibonacci.fib</span></code></a> yourself.</p>
</div></div><div class="proof proof-type-exercise" id="id7">

    <div class="proof-title">
        <span class="proof-type">Exercise 2.3</span>
        
    </div><div class="proof-content">
<p>Accept the <a class="reference external" href="https://classroom.github.com/a/gJ5cd5wM">first Github Classroom assignment for this module</a> and clone it into your course folder. The assignment
repository just contains a <code class="file docutils literal notranslate"><span class="pre">README</span></code> and some tests. Your job in the
following exercises will be to populate it with the remaining content.</p>
</div></div><div class="proof proof-type-exercise" id="id8">

    <div class="proof-title">
        <span class="proof-type">Exercise 2.4</span>
        
    </div><div class="proof-content">
<p>Create a new Python <a class="reference internal" href="#term-package"><span class="xref std std-term">package</span></a> named <code class="xref py py-mod docutils literal notranslate"><span class="pre">math_utils</span></code> containing a
<a class="reference internal" href="#term-module"><span class="xref std std-term">module</span></a> called <code class="xref py py-mod docutils literal notranslate"><span class="pre">primes</span></code>. In the <code class="xref py py-mod docutils literal notranslate"><span class="pre">primes</span></code> module define a
function <code class="xref py py-func docutils literal notranslate"><span class="pre">isprime()</span></code> which takes in a single integer argument and
returns <a class="reference external" href="https://docs.python.org/3/library/constants.html#True" title="(in Python v3.10)"><code class="xref py py-obj docutils literal notranslate"><span class="pre">True</span></code></a> or <a class="reference external" href="https://docs.python.org/3/library/constants.html#False" title="(in Python v3.10)"><code class="xref py py-obj docutils literal notranslate"><span class="pre">False</span></code></a> depending on whether or not the argument is prime.
There is no need to be sophisticated in the algorithm used to check for
primeness, simply checking whether the number is zero modulo any of the
integers less than its square root will be fine. Test your code by running
the following in your week 2 exercise repository:</p>
<div class="highlight-console notranslate"><div class="highlight"><pre><span></span><span class="gp">$ </span>pytest tests/test_exercise_2_4.py
</pre></div>
</div>
<p>Then push your code to GitHub and check that the tests pass there too.</p>
<div class="admonition hint">
<p class="admonition-title">Hint</p>
<p>The Python modulo operator is <code class="xref py py-obj docutils literal notranslate"><span class="pre">%</span></code>. For example:</p>
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="gp">In [1]: </span><span class="mi">4</span> <span class="o">%</span> <span class="mi">3</span>
<span class="gh">Out[1]: </span><span class="go">1</span>
</pre></div>
</div>
</div>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>After this and every exercise in which you write code, ensure that you
add any new files to git, commit all of your changes, and push to
GitHub. Then ensure that the tests pass on GitHub. For more information
about how to do any of these, refer back the <a class="reference external" href="https://imperial-fons-computing.github.io/git.html#github-classroom-exercise" title="(in Installation instructions for FoNS v2020.0)"><span class="xref std std-ref">Faculty of Natural Sciences
Git instructions</span></a>.</p>
</div>
</div></div><div class="proof proof-type-exercise" id="id9">

    <div class="proof-title">
        <span class="proof-type">Exercise 2.5</span>
        
    </div><div class="proof-content">
<p>Following <a class="reference internal" href="#installable-packages"><span class="std std-numref">Section 2.6.2</span></a>, create a <code class="file docutils literal notranslate"><span class="pre">setup.py</span></code> file in
your exercise repository, so that the <code class="xref py py-mod docutils literal notranslate"><span class="pre">math_utils</span></code> <a class="reference internal" href="#term-package"><span class="xref std std-term">package</span></a> is
installable.</p>
<p>Pytest can’t easily test installability for you, so once you have managed to
install your package yourself, commit and push to github to check that the
tests there are also able to install your package.</p>
</div></div><div class="proof proof-type-exercise" id="id10">

    <div class="proof-title">
        <span class="proof-type">Exercise 2.6</span>
        
    </div><div class="proof-content">
<p>Add an <a class="reference external" href="https://docs.python.org/3/reference/simple_stmts.html#import" title="(in Python v3.10)"><code class="xref std std-keyword docutils literal notranslate"><span class="pre">import</span></code></a> to <code class="file docutils literal notranslate"><span class="pre">math_utils.__init__.py</span></code> so that the following
code will work:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">math_utils</span> <span class="kn">import</span> <span class="n">isprime</span>
</pre></div>
</div>
</div></div><p class="rubric">Footnotes</p>
<dl class="footnote brackets">
<dt class="label" id="peters"><span class="brackets"><a class="fn-backref" href="#id2">1</a></span></dt>
<dd><p>Tim Peters, <a class="reference external" href="https://www.python.org/dev/peps/pep-0020/">“PEP 20 – The Zen Of Python” (2004)</a></p>
</dd>
<dt class="label" id="interface-errors"><span class="brackets"><a class="fn-backref" href="#id4">2</a></span></dt>
<dd><p>Of course if you find a case where it appears that the
tests don’t honour the interface published in the exercise, you should raise
an issue reporting this.</p>
</dd>
</dl>
</section>
</section>


            <div class="clearer"></div>
          </div>
        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="footer" role="contentinfo">
        &#169; Copyright 2019-2021, David A. Ham. Modified by Patrick E. Farrell.
      Created using <a href="https://www.sphinx-doc.org/">Sphinx</a> 4.5.0.
    </div>
  </body>
</html>