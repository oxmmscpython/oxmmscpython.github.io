
<!DOCTYPE html>

<html>
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" /><meta name="generator" content="Docutils 0.17.1: http://docutils.sourceforge.net/" />

    <title>9. Trees and directed acyclic graphs &#8212; Object oriented programming in Python for mathematicians 2021.0 documentation</title>
    <link rel="stylesheet" type="text/css" href="_static/pygments.css" />
    <link rel="stylesheet" type="text/css" href="_static/fenics.css" />
    <link rel="stylesheet" type="text/css" href="_static/proof.css" />
    <link rel="stylesheet" type="text/css" href="_static/graphviz.css" />
    <link rel="stylesheet" type="text/css" href="_static/panels-main.c949a650a448cc0ae9fd3441c0e17fb0.css" />
    <link rel="stylesheet" type="text/css" href="_static/panels-bootstrap.5fd3999ee7762ccc51105388f4a9d115.css" />
    <link rel="stylesheet" type="text/css" href="_static/panels-variables.06eb56fa6e07937060861dad626602ad.css" />
    <script data-url_root="./" id="documentation_options" src="_static/documentation_options.js"></script>
    <script src="_static/jquery.js"></script>
    <script src="_static/underscore.js"></script>
    <script src="_static/doctools.js"></script>
    <script src="_static/proof.js"></script>
    <script async="async" src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
    <link rel="index" title="Index" href="genindex.html" />
    <link rel="search" title="Search" href="search.html" />
    <link rel="prev" title="8. Debugging and testing" href="9_debugging.html" />
<!--[if lte IE 6]>
<link rel="stylesheet" href="_static/ie6.css" type="text/css" media="screen" charset="utf-8" />
<![endif]-->
<!-- Global site tag (gtag.js) - Google Analytics -->
<script async src="https://www.googletagmanager.com/gtag/js?id=G-0EFVH5C4DC"></script>
<script>
  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());

  gtag('config', 'G-0EFVH5C4DC');
</script>
<link rel="stylesheet" href="_static/featured.css">


<link rel="shortcut icon" href="_static/icon.ico" />


  </head><body>
<div class="wrapper">
  <div id="access">
    <div class="menu">
      <ul>
          <li class="page_item"><a href="https://github.com/oxmmscpython/object-oriented-programming" title="GitHub">GitHub</a></li>
      </ul>
    </div><!-- .menu -->
  </div><!-- #access -->
</div><!-- #wrapper -->


    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body" role="main">
            
  <section id="trees-and-directed-acyclic-graphs">
<span id="trees"></span><h1><span class="section-number">9. </span>Trees and directed acyclic graphs<a class="headerlink" href="#trees-and-directed-acyclic-graphs" title="Permalink to this headline">¶</a></h1>
<p>The <a class="reference internal" href="5_abstract_data_types.html#term-abstract-data-type"><span class="xref std std-term">abstract data types</span></a> that we met in
<a class="reference internal" href="5_abstract_data_types.html#abstract-data-types"><span class="std std-numref">Week 5</span></a> were all fairly simple sequences of objects that
were extensible in different ways. If that were all the sum total of abstract
data types then the reader might reasonably wonder what all the fuss is about.
In this chapter we’ll look at <a class="reference internal" href="#term-tree"><span class="xref std std-term">trees</span></a> and <a class="reference internal" href="#term-directed-acyclic-graph"><span class="xref std std-term">directed acyclic
graphs (DAGs)</span></a>, which are abstract data types which
look very different from the ones we’ve met so far.</p>
<p>Trees and DAGs provide some great examples of <a class="reference internal" href="8_inheritance.html#term-inheritance"><span class="xref std std-term">inheritance</span></a> and give us
the chance to look at some new algorithm types. They are also the core data
types underpinning computer algebra systems, so studying trees and DAGs will
enable us to gain a little insight into how systems such as <a class="reference external" href="https://www.sympy.org">SymPy</a>, <a class="reference external" href="https://www.maplesoft.com">Maple</a> and
<a class="reference external" href="https://www.wolfram.com/mathematica/">Mathematica</a> actually work. As we come
to the latter parts of the course, we’ll also step back a little from laying out
a lot of code, and instead focus on the mathematical structure of the objects in
question. When we come to the exercises, you will then take a little more
responsibility for translating the maths into code.</p>
<section id="the-splat-and-double-splat-operators">
<h2><span class="section-number">9.1. </span>The splat and double splat operators<a class="headerlink" href="#the-splat-and-double-splat-operators" title="Permalink to this headline">¶</a></h2>
<details class="sphinx-bs dropdown card mb-3">
<summary class="summary-title card-header">
Video: splat and double splat.<div class="summary-down docutils">
<svg version="1.1" width="24" height="24" class="octicon octicon-chevron-down" viewBox="0 0 24 24" aria-hidden="true"><path fill-rule="evenodd" d="M5.22 8.72a.75.75 0 000 1.06l6.25 6.25a.75.75 0 001.06 0l6.25-6.25a.75.75 0 00-1.06-1.06L12 14.44 6.28 8.72a.75.75 0 00-1.06 0z"></path></svg></div>
<div class="summary-up docutils">
<svg version="1.1" width="24" height="24" class="octicon octicon-chevron-up" viewBox="0 0 24 24" aria-hidden="true"><path fill-rule="evenodd" d="M18.78 15.28a.75.75 0 000-1.06l-6.25-6.25a.75.75 0 00-1.06 0l-6.25 6.25a.75.75 0 101.06 1.06L12 9.56l5.72 5.72a.75.75 0 001.06 0z"></path></svg></div>
</summary><div class="summary-content card-body docutils">
<div class="vimeo docutils container">
<iframe src="https://player.vimeo.com/video/523477744"
frameborder="0" allow="autoplay; fullscreen"
allowfullscreen></iframe></div>
</div>
</details><p>Before we go on to write code for trees and their traversal,  we need to
digress ever so slightly in order to explain a new piece of syntax. We’re going
to want to write  functions that can take a variable number of arguments. For
example, we’re going to want the <a class="reference internal" href="3_objects.html#term-constructor"><span class="xref std std-term">constructor</span></a> of a tree node object to
be able to take a variable number of children. We can do this by writing the
relevant parameter as <code class="xref py py-obj docutils literal notranslate"><span class="pre">*children</span></code>. The character <code class="xref py py-obj docutils literal notranslate"><span class="pre">*</span></code> in this case is the
argument packing operator, also known as the <em>splat</em> operator <a class="footnote-reference brackets" href="#splat" id="id1">2</a>. When
used in the parameter list of a function, splat takes all of the remaining
<a class="reference external" href="https://docs.python.org/3/glossary.html#term-argument" title="(in Python v3.10)"><span class="xref std std-term">positional arguments</span></a> provided by the caller and packs them
up in a tuple. In this case, this enables any number of child nodes to be
specified for each node.</p>
<p>The splat operator can also be used when calling a function. In that case it
acts as a sequence unpacking operator, turning a sequence into separate
arguments. For example:</p>
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="gp">In [1]: </span><span class="n">a</span> <span class="o">=</span> <span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">)</span>

<span class="gp">In [2]: </span><span class="nb">print</span><span class="p">(</span><span class="o">*</span><span class="n">a</span><span class="p">)</span>
<span class="go">1 2 3</span>
</pre></div>
</div>
<p>which is identical to:</p>
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="gp">In [3]: </span><span class="nb">print</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">)</span>
<span class="go">1 2 3</span>
</pre></div>
</div>
<p>but different from:</p>
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="gp">In [4]: </span><span class="nb">print</span><span class="p">(</span><span class="n">a</span><span class="p">)</span>
<span class="go">(1, 2, 3)</span>
</pre></div>
</div>
<p>The double splat operator, <code class="xref py py-obj docutils literal notranslate"><span class="pre">**</span></code> plays a similar role to the single splat
operator, but packs and unpacks <a class="reference external" href="https://docs.python.org/3/glossary.html#term-argument" title="(in Python v3.10)"><span class="xref std std-term">keyword arguments</span></a> instead of
positional arguments. When used in the <a class="reference external" href="https://docs.python.org/3/glossary.html#term-parameter" title="(in Python v3.10)"><span class="xref std std-term">parameter</span></a> list of a function,
<code class="xref py py-obj docutils literal notranslate"><span class="pre">**</span></code> gathers all of the keyword arguments that the caller passes, other than any
which are explicitly named in the interface. The result is a <a class="reference external" href="https://docs.python.org/3/library/stdtypes.html#dict" title="(in Python v3.10)"><code class="xref py py-class docutils literal notranslate"><span class="pre">dict</span></code></a> whose
keys are the argument names, and whose values are the arguments.
<a class="reference internal" href="#kwarg-packing"><span class="std std-numref">Listing 9.1</span></a> demonstrates the argument packing function of <code class="xref py py-obj docutils literal notranslate"><span class="pre">**</span></code>,
while <a class="reference internal" href="#kwarg-unpacking"><span class="std std-numref">Listing 9.2</span></a> shows the unpacking function.</p>
<div class="literal-block-wrapper docutils container" id="id4">
<span id="kwarg-packing"></span><div class="code-block-caption"><span class="caption-number">Listing 9.1 </span><span class="caption-text">An illustration of keyword argument packing. All of the keyword
arguments are packed into the dictionary <code class="xref py py-data docutils literal notranslate"><span class="pre">kwargs</span></code>, except for <code class="xref py py-obj docutils literal notranslate"><span class="pre">b</span></code>,
because that explicitly appears in the parameter list of <code class="xref py py-func docutils literal notranslate"><span class="pre">fn()</span></code>.</span><a class="headerlink" href="#id4" title="Permalink to this code">¶</a></div>
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="gp">In [1]: </span><span class="k">def</span> <span class="nf">fn</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
<span class="gp">   ...: </span>    <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;a:&quot;</span><span class="p">,</span> <span class="n">a</span><span class="p">)</span>
<span class="gp">   ...: </span>    <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;b:&quot;</span><span class="p">,</span> <span class="n">b</span><span class="p">)</span>
<span class="gp">   ...: </span>    <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;kwargs:&quot;</span><span class="p">,</span> <span class="n">kwargs</span><span class="p">)</span>
<span class="gp">   ...:</span>

<span class="gp">In [2]: </span><span class="n">fn</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">f</span><span class="o">=</span><span class="mi">3</span><span class="p">,</span> <span class="n">b</span><span class="o">=</span><span class="mi">2</span><span class="p">,</span> <span class="n">g</span><span class="o">=</span><span class="s2">&quot;hello&quot;</span><span class="p">)</span>
<span class="go">a: 1</span>
<span class="go">b: 2</span>
<span class="go">kwargs: {&#39;f&#39;: 3, &#39;g&#39;: &#39;hello&#39;}</span>
</pre></div>
</div>
</div>
<div class="literal-block-wrapper docutils container" id="id5">
<span id="kwarg-unpacking"></span><div class="code-block-caption"><span class="caption-number">Listing 9.2 </span><span class="caption-text">Keyword argument unpacking. Notice that the arguments matching the
explicitly named keywords are unpacked, while the remainder are repacked
into the <code class="xref py py-obj docutils literal notranslate"><span class="pre">**kwargs</span></code> parameter.</span><a class="headerlink" href="#id5" title="Permalink to this code">¶</a></div>
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="gp">In [3]: </span><span class="n">kw</span> <span class="o">=</span> <span class="p">{</span><span class="s2">&quot;a&quot;</span><span class="p">:</span> <span class="s2">&quot;mary&quot;</span><span class="p">,</span> <span class="s2">&quot;b&quot;</span><span class="p">:</span> <span class="s2">&quot;had&quot;</span><span class="p">,</span> <span class="s2">&quot;c&quot;</span><span class="p">:</span> <span class="s2">&quot;a&quot;</span><span class="p">,</span> <span class="s2">&quot;d&quot;</span><span class="p">:</span> <span class="s2">&quot;little&quot;</span><span class="p">,</span> <span class="s2">&quot;e&quot;</span><span class="p">:</span> <span class="s2">&quot;lamb&quot;</span><span class="p">}</span>

<span class="gp">In [4]: </span><span class="n">fn</span><span class="p">(</span><span class="o">**</span><span class="n">kw</span><span class="p">)</span>
<span class="go">a: mary</span>
<span class="go">b: had</span>
<span class="go">kwargs: {&#39;c&#39;: &#39;a&#39;, &#39;d&#39;: &#39;little&#39;, &#39;e&#39;: &#39;lamb&#39;}</span>
</pre></div>
</div>
</div>
<p>Combining the splat and double splat operators, it is possible to write a
function that will accept any combination of positional and keyword arguments.
This is often useful if the function is intended to pass these arguments through
to another function, without knowing anything about that inner function. For
example:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">fn</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
    <span class="o">...</span>
    <span class="n">a</span> <span class="o">=</span>  <span class="n">inner_fn</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
    <span class="o">...</span>
</pre></div>
</div>
<p>The names <code class="xref py py-obj docutils literal notranslate"><span class="pre">*args</span></code> and <code class="xref py py-obj docutils literal notranslate"><span class="pre">**kwargs</span></code> are the conventional names in
cases where nothing more specific is known about the parameters in question.</p>
</section>
<section id="some-definitions">
<h2><span class="section-number">9.2. </span>Some definitions<a class="headerlink" href="#some-definitions" title="Permalink to this headline">¶</a></h2>
<p>Trees and DAGs are examples of graphs, a type of mathematical object that you
may have met in previous courses:</p>
<div class="proof proof-type-definition" id="id6">

    <div class="proof-title">
        <span class="proof-type">Definition 9.1</span>
        
            <span class="proof-title-name">(Graph)</span>
        
    </div><div class="proof-content">
<p>A <em>graph</em> <span class="math notranslate nohighlight">\((V, E)\)</span> is a set <span class="math notranslate nohighlight">\(V\)</span> known as the vertices or nodes,
and a set of pairs of vertices, <span class="math notranslate nohighlight">\(E\)</span>, known as the edges.</p>
</div></div><p>A graph describes connections between its vertices, and can be used to model a
huge range of interconnected networks. <a class="reference internal" href="#graph"><span class="std std-numref">Fig. 9.1</span></a> illustrates a simple example.</p>
<figure class="align-center" id="id7">
<span id="graph"></span><div class="graphviz"><object data="_images/graphviz-6b78642109c5b2fb5b298391cf1f651e396c0f4b.svg" type="image/svg+xml" class="graphviz">
<p class="warning">strict graph{
    a -- b
    b -- c
    b -- d
    c -- f
    f -- b
    d -- a
    f -- a
    e -- c
    e -- d
}</p></object></div>
<figcaption>
<p><span class="caption-number">Fig. 9.1 </span><span class="caption-text">A graphical representation of the graph <span class="math notranslate nohighlight">\((\{a, b, c, d, e,
f\}, \{(a, b), (a, d), (a, f), (b, c), (b, d), (b, f), (c, e), (c, f), (d, e) \})\)</span></span><a class="headerlink" href="#id7" title="Permalink to this image">¶</a></p>
</figcaption>
</figure>
<div class="proof proof-type-definition" id="id8">

    <div class="proof-title">
        <span class="proof-type">Definition 9.2</span>
        
            <span class="proof-title-name">(Directed graph)</span>
        
    </div><div class="proof-content">
<p>A <em>directed graph</em> is a graph in which the pair of nodes forming each edge
is ordered. In other words each edge points <em>from</em> one node (the <em>source</em>)
and <em>to</em> another (the <em>target</em>).</p>
</div></div><p><a class="reference internal" href="#digraph"><span class="std std-numref">Fig. 9.2</span></a> shows a directed graph with similar topology to the previous example.</p>
<figure class="align-center" id="id9">
<span id="digraph"></span><div class="graphviz"><object data="_images/graphviz-707ee9737830d0789d1828d8465ddd8e6b37fd36.svg" type="image/svg+xml" class="graphviz">
<p class="warning">strict digraph{
    a -&gt; b [color=red]
    b -&gt; c
    b -&gt; d [color=red]
    c -&gt; f
    f -&gt; b
    d -&gt; a [color=red]
    f -&gt; a
    e -&gt; c
    e -&gt; d
}</p></object></div>
<figcaption>
<p><span class="caption-number">Fig. 9.2 </span><span class="caption-text">A directed graph. The edges in red depict a cycle.</span><a class="headerlink" href="#id9" title="Permalink to this image">¶</a></p>
</figcaption>
</figure>
<div class="proof proof-type-definition" id="id10">

    <div class="proof-title">
        <span class="proof-type">Definition 9.3</span>
        
            <span class="proof-title-name">(Cycle)</span>
        
    </div><div class="proof-content">
<p>A <em>cycle</em> in a graph is a sequence of edges such that the target of each
edge is the source of the next, and the target of the last edge is the
source of the first.</p>
</div></div><div class="proof proof-type-definition" id="id11">

    <div class="proof-title">
        <span class="proof-type">Definition 9.4</span>
        
            <span class="proof-title-name">(Directed acyclic graph.)</span>
        
    </div><div class="proof-content">
<p>A directed acyclic graph (DAG) is a directed graph in which there are no cycles.</p>
</div></div><p><a class="reference internal" href="#dag"><span class="std std-numref">Fig. 9.3</span></a> shows a directed acyclic graph, or DAG. The cyclic nature of the
graph imposes a certain form of hierarchy. For example the graph formed by the
<a class="reference internal" href="8_inheritance.html#term-inheritance"><span class="xref std std-term">inheritance</span></a> relationship of classes is a DAG. The hierarchy implied by a
DAG also lends itself to similar nomenclature to that which we use for class
hierarchies: the source node of an edge is also referred to as the <em>parent node</em>
and the target nodes of the edges emerging from a node are referred to as its
<em>child nodes</em> or <em>children</em>.</p>
<figure class="align-center" id="id12">
<span id="dag"></span><div class="graphviz"><object data="_images/graphviz-8dc47f9701ffada1396d9c18501e2a406d3c71c7.svg" type="image/svg+xml" class="graphviz">
<p class="warning">strict digraph{
    a -&gt; b
    b -&gt; c
    b -&gt; d
    c -&gt; f
    b -&gt; f
    a -&gt; f
    e -&gt; c
    e -&gt; d
}</p></object></div>
<figcaption>
<p><span class="caption-number">Fig. 9.3 </span><span class="caption-text">A directed acyclic graph, formed by reversing edges in
<a class="reference internal" href="#digraph"><span class="std std-numref">Fig. 9.2</span></a> so that no cycles remain.</span><a class="headerlink" href="#id12" title="Permalink to this image">¶</a></p>
</figcaption>
</figure>
<div class="proof proof-type-definition" id="id13">

    <div class="proof-title">
        <span class="proof-type">Definition 9.5</span>
        
            <span class="proof-title-name">(Tree)</span>
        
    </div><div class="proof-content">
<p>A <em>tree</em> is a directed acyclic graph in which each node is the target of
exactly one edge, except for one node (the <em>root node</em>) which is not the
target of any edges <a class="footnote-reference brackets" href="#tree-def" id="id2">1</a>.</p>
</div></div><figure class="align-center" id="id14">
<span id="tree-image"></span><div class="graphviz"><object data="_images/graphviz-7d68f8bae8445d49243aa04c9d8c0b636d1a2872.svg" type="image/svg+xml" class="graphviz">
<p class="warning">strict digraph{
    a -&gt; b
    b -&gt; d
    b -&gt; e
    b -&gt; f
    a -&gt; c
    c -&gt; g
}</p></object></div>
<figcaption>
<p><span class="caption-number">Fig. 9.4 </span><span class="caption-text">A tree.</span><a class="headerlink" href="#id14" title="Permalink to this image">¶</a></p>
</figcaption>
</figure>
<p>Tree nodes with no children are called <em>leaf nodes</em>.</p>
</section>
<section id="data-structures-for-trees">
<h2><span class="section-number">9.3. </span>Data structures for trees<a class="headerlink" href="#data-structures-for-trees" title="Permalink to this headline">¶</a></h2>
<details class="sphinx-bs dropdown card mb-3">
<summary class="summary-title card-header">
Tree data structures.<div class="summary-down docutils">
<svg version="1.1" width="24" height="24" class="octicon octicon-chevron-down" viewBox="0 0 24 24" aria-hidden="true"><path fill-rule="evenodd" d="M5.22 8.72a.75.75 0 000 1.06l6.25 6.25a.75.75 0 001.06 0l6.25-6.25a.75.75 0 00-1.06-1.06L12 14.44 6.28 8.72a.75.75 0 00-1.06 0z"></path></svg></div>
<div class="summary-up docutils">
<svg version="1.1" width="24" height="24" class="octicon octicon-chevron-up" viewBox="0 0 24 24" aria-hidden="true"><path fill-rule="evenodd" d="M18.78 15.28a.75.75 0 000-1.06l-6.25-6.25a.75.75 0 00-1.06 0l-6.25 6.25a.75.75 0 101.06 1.06L12 9.56l5.72 5.72a.75.75 0 001.06 0z"></path></svg></div>
</summary><div class="summary-content card-body docutils">
<div class="vimeo docutils container">
<iframe src="https://player.vimeo.com/video/523477713"
frameborder="0" allow="autoplay; fullscreen"
allowfullscreen></iframe></div>
</div>
</details><p>Unlike the sequence types we have previously met, trees are not linear objects.
If we wish to iterate through every node in the tree then we have a choices to
make about the order in which we do so. In particular, there are two obvious
classes of traversal order:</p>
<dl class="simple">
<dt>preorder traversal</dt><dd><p>A traversal in which each node is always visited <em>before</em> its children.</p>
</dd>
<dt>postorder traversal</dt><dd><p>A traversal order in which each node is always visited <em>after</em> its children.</p>
</dd>
</dl>
<p>Note that neither order is unique: a node can have any number of children and
the definitions are silent on the order in which these are visited. There is
furthermore no guarantee that the children of a node will be visited immediately
before or after their parent, and once we look at visitors for DAGs it will
become apparent that it is not always possible to do so.</p>
<div class="literal-block-wrapper docutils container" id="id15">
<span id="treenode"></span><div class="code-block-caption"><span class="caption-number">Listing 9.3 </span><span class="caption-text">A basic tree implementation. This code is available as the
<a class="reference internal" href="example_code.html#example_code.graphs.TreeNode" title="example_code.graphs.TreeNode"><code class="xref py py-class docutils literal notranslate"><span class="pre">example_code.graphs.TreeNode</span></code></a> class.</span><a class="headerlink" href="#id15" title="Permalink to this code">¶</a></div>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="linenos"> 1</span><span class="k">class</span> <span class="nc">TreeNode</span><span class="p">:</span>
<span class="linenos"> 2</span>    <span class="sd">&quot;&quot;&quot;A basic tree implementation.</span>
<span class="linenos"> 3</span>
<span class="linenos"> 4</span><span class="sd">    Observe that a tree is simply a collection of connected TreeNodes.</span>
<span class="linenos"> 5</span>
<span class="linenos"> 6</span><span class="sd">    Parameters</span>
<span class="linenos"> 7</span><span class="sd">    ----------</span>
<span class="linenos"> 8</span><span class="sd">    value:</span>
<span class="linenos"> 9</span><span class="sd">        An arbitrary value associated with this node.</span>
<span class="linenos">10</span><span class="sd">    children:</span>
<span class="linenos">11</span><span class="sd">        The TreeNodes which are the children of this node.</span>
<span class="linenos">12</span><span class="sd">    &quot;&quot;&quot;</span>
<span class="linenos">13</span>
<span class="linenos">14</span>    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">value</span><span class="p">,</span> <span class="o">*</span><span class="n">children</span><span class="p">):</span>
<span class="linenos">15</span>        <span class="bp">self</span><span class="o">.</span><span class="n">value</span> <span class="o">=</span> <span class="n">value</span>
<span class="linenos">16</span>        <span class="bp">self</span><span class="o">.</span><span class="n">children</span> <span class="o">=</span> <span class="nb">tuple</span><span class="p">(</span><span class="n">children</span><span class="p">)</span>
<span class="linenos">17</span>
<span class="linenos">18</span>    <span class="k">def</span> <span class="fm">__repr__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="linenos">19</span>        <span class="sd">&quot;&quot;&quot;Return the canonical string representation.&quot;&quot;&quot;</span>
<span class="linenos">20</span>        <span class="k">return</span> <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="nb">type</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="vm">__name__</span><span class="si">}{</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">value</span><span class="p">,)</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">children</span><span class="si">}</span><span class="s2">&quot;</span>
<span class="linenos">21</span>
<span class="linenos">22</span>    <span class="k">def</span> <span class="fm">__str__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="linenos">23</span>        <span class="sd">&quot;&quot;&quot;Serialise the tree recursively as parent -&gt; (children).&quot;&quot;&quot;</span>
<span class="linenos">24</span>        <span class="n">childstring</span> <span class="o">=</span> <span class="s2">&quot;, &quot;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="nb">map</span><span class="p">(</span><span class="nb">str</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">children</span><span class="p">))</span>
<span class="linenos">25</span>        <span class="k">return</span> <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">value</span><span class="si">!s}</span><span class="s2"> -&gt; (</span><span class="si">{</span><span class="n">childstring</span><span class="si">}</span><span class="s2">)&quot;</span>
</pre></div>
</div>
</div>
<p><a class="reference internal" href="#treenode"><span class="std std-numref">Listing 9.3</span></a> shows a very simple class which implements a tree. For
example, we can represent the tree in <a class="reference internal" href="#tree-image"><span class="std std-numref">Fig. 9.4</span></a> using:</p>
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="gp">In [1]: </span><span class="kn">from</span> <span class="nn">example_code.graphs</span> <span class="kn">import</span> <span class="n">TreeNode</span>

<span class="gp">In [2]: </span><span class="n">tree</span> <span class="o">=</span> <span class="n">TreeNode</span><span class="p">(</span><span class="s2">&quot;a&quot;</span><span class="p">,</span> <span class="n">TreeNode</span><span class="p">(</span><span class="s2">&quot;b&quot;</span><span class="p">,</span> <span class="n">TreeNode</span><span class="p">(</span><span class="s2">&quot;d&quot;</span><span class="p">),</span> <span class="n">TreeNode</span><span class="p">(</span><span class="s2">&quot;e&quot;</span><span class="p">),</span> <span class="n">TreeNode</span><span class="p">(</span><span class="s2">&quot;f&quot;</span><span class="p">)),</span>
<span class="gp">   ...: </span>                     <span class="n">TreeNode</span><span class="p">(</span><span class="s2">&quot;c&quot;</span><span class="p">,</span> <span class="n">TreeNode</span><span class="p">(</span><span class="s2">&quot;g&quot;</span><span class="p">)))</span>

<span class="gp">In [3]: </span><span class="nb">print</span><span class="p">(</span><span class="n">tree</span><span class="p">)</span>
<span class="go">a -&gt; (b -&gt; (d -&gt; (), e -&gt; (), f -&gt; ()), c -&gt; (g -&gt; ()))</span>
</pre></div>
</div>
<p>The reader might immediately observe that serialised trees can be a little hard
to read! This is the reason that trees are often represented by diagrams.</p>
<section id="traversing-treenode">
<h3><span class="section-number">9.3.1. </span>Traversing <a class="reference internal" href="example_code.html#example_code.graphs.TreeNode" title="example_code.graphs.TreeNode"><code class="xref py py-class docutils literal notranslate"><span class="pre">TreeNode</span></code></a><a class="headerlink" href="#traversing-treenode" title="Permalink to this headline">¶</a></h3>
<details class="sphinx-bs dropdown card mb-3">
<summary class="summary-title card-header">
Video: tree traversal.<div class="summary-down docutils">
<svg version="1.1" width="24" height="24" class="octicon octicon-chevron-down" viewBox="0 0 24 24" aria-hidden="true"><path fill-rule="evenodd" d="M5.22 8.72a.75.75 0 000 1.06l6.25 6.25a.75.75 0 001.06 0l6.25-6.25a.75.75 0 00-1.06-1.06L12 14.44 6.28 8.72a.75.75 0 00-1.06 0z"></path></svg></div>
<div class="summary-up docutils">
<svg version="1.1" width="24" height="24" class="octicon octicon-chevron-up" viewBox="0 0 24 24" aria-hidden="true"><path fill-rule="evenodd" d="M18.78 15.28a.75.75 0 000-1.06l-6.25-6.25a.75.75 0 00-1.06 0l-6.25 6.25a.75.75 0 101.06 1.06L12 9.56l5.72 5.72a.75.75 0 001.06 0z"></path></svg></div>
</summary><div class="summary-content card-body docutils">
<div class="vimeo docutils container">
<iframe src="https://player.vimeo.com/video/523477719"
frameborder="0" allow="autoplay; fullscreen"
allowfullscreen></iframe></div>
</div>
</details><p>A function which traverses a tree is often called a tree visitor, because it
visits every node in the tree. What does it do when it visits? Well it could do
just about anything that one can do on the basis of the data available at that
node, and the results of visiting whichever nodes have already been visited. The
way that such a wide range of options can be accommodated is by the tree
traversal function taking another function as an argument. This enables the
caller to specify what should happen when each node is visited. An approach like
this is a good example of a <a class="reference internal" href="5_abstract_data_types.html#term-separation-of-concerns"><span class="xref std std-term">separation of concerns</span></a>: the process of
visiting a tree in the correct order is separated from the question of what to
do when we get there.</p>
<p>We’ll consider postorder traversal first, as it’s the easier to implement.</p>
<div class="literal-block-wrapper docutils container" id="id16">
<span id="postorder-recursive"></span><div class="code-block-caption"><span class="caption-number">Listing 9.4 </span><span class="caption-text">A basic postorder tree visitor. This code is also available as
<a class="reference internal" href="example_code.html#example_code.graphs.postvisitor" title="example_code.graphs.postvisitor"><code class="xref py py-func docutils literal notranslate"><span class="pre">example_code.graphs.postvisitor()</span></code></a>.</span><a class="headerlink" href="#id16" title="Permalink to this code">¶</a></div>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="linenos"> 1</span><span class="k">def</span> <span class="nf">postvisitor</span><span class="p">(</span><span class="n">tree</span><span class="p">,</span> <span class="n">fn</span><span class="p">):</span>
<span class="linenos"> 2</span>    <span class="sd">&quot;&quot;&quot;Traverse tree in postorder applying a function to every node.</span>
<span class="linenos"> 3</span>
<span class="linenos"> 4</span><span class="sd">    Parameters</span>
<span class="linenos"> 5</span><span class="sd">    ----------</span>
<span class="linenos"> 6</span><span class="sd">    tree: TreeNode</span>
<span class="linenos"> 7</span><span class="sd">        The tree to be visited.</span>
<span class="linenos"> 8</span><span class="sd">    fn: function(node, *fn_children)</span>
<span class="linenos"> 9</span><span class="sd">        A function to be applied at each node. The function should take the</span>
<span class="linenos">10</span><span class="sd">        node to be visited as its first argument, and the results of visiting</span>
<span class="linenos">11</span><span class="sd">        its children as any further arguments.</span>
<span class="linenos">12</span><span class="sd">    &quot;&quot;&quot;</span>
<span class="linenos">13</span>    <span class="k">return</span> <span class="n">fn</span><span class="p">(</span><span class="n">tree</span><span class="p">,</span> <span class="o">*</span><span class="p">(</span><span class="n">postvisitor</span><span class="p">(</span><span class="n">c</span><span class="p">,</span> <span class="n">fn</span><span class="p">)</span> <span class="k">for</span> <span class="n">c</span> <span class="ow">in</span> <span class="n">tree</span><span class="o">.</span><span class="n">children</span><span class="p">))</span>
</pre></div>
</div>
</div>
<p><a class="reference internal" href="#postorder-recursive"><span class="std std-numref">Listing 9.4</span></a> implements this visitor. Notice that there is only
one line of executable code, at line 14. This recursively calls
<a class="reference internal" href="example_code.html#example_code.graphs.postvisitor" title="example_code.graphs.postvisitor"><code class="xref py py-func docutils literal notranslate"><span class="pre">postvisitor()</span></code></a> on all of the children of the current
node, <em>before</em> calling <code class="xref py py-func docutils literal notranslate"><span class="pre">fn()</span></code> on the current node. As a trivial example,
let’s print out the nodes of the graph in <a class="reference internal" href="#tree-image"><span class="std std-numref">Fig. 9.4</span></a> in postorder:</p>
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="gp">In [1]: </span><span class="kn">from</span> <span class="nn">example_code.graphs</span> <span class="kn">import</span> <span class="n">TreeNode</span><span class="p">,</span> <span class="n">postvisitor</span>

<span class="gp">In [2]: </span><span class="n">tree</span> <span class="o">=</span> <span class="n">TreeNode</span><span class="p">(</span><span class="s2">&quot;a&quot;</span><span class="p">,</span> <span class="n">TreeNode</span><span class="p">(</span><span class="s2">&quot;b&quot;</span><span class="p">,</span> <span class="n">TreeNode</span><span class="p">(</span><span class="s2">&quot;d&quot;</span><span class="p">),</span> <span class="n">TreeNode</span><span class="p">(</span><span class="s2">&quot;e&quot;</span><span class="p">),</span> <span class="n">TreeNode</span><span class="p">(</span><span class="s2">&quot;f&quot;</span><span class="p">)),</span>
<span class="gp">   ...: </span>                     <span class="n">TreeNode</span><span class="p">(</span><span class="s2">&quot;c&quot;</span><span class="p">,</span> <span class="n">TreeNode</span><span class="p">(</span><span class="s2">&quot;g&quot;</span><span class="p">)))</span>

<span class="gp">In [3]: </span><span class="n">fn</span> <span class="o">=</span> <span class="k">lambda</span> <span class="n">n</span><span class="p">,</span> <span class="o">*</span><span class="n">c</span><span class="p">:</span> <span class="nb">print</span><span class="p">(</span><span class="n">n</span><span class="o">.</span><span class="n">value</span><span class="p">)</span>

<span class="gp">In [4]: </span><span class="n">postvisitor</span><span class="p">(</span><span class="n">tree</span><span class="p">,</span> <span class="n">fn</span><span class="p">)</span>
<span class="go">d</span>
<span class="go">e</span>
<span class="go">f</span>
<span class="go">b</span>
<span class="go">g</span>
<span class="go">c</span>
<span class="go">a</span>
</pre></div>
</div>
<p>Observe that d, e, and f are printed before b; g is printed before c; and both b
and c are printed before a.</p>
<p>The preceding example is possibly a little too trivial,
because we didn’t at all use the result of visiting the child nodes in visiting
the parent node. For a marginally less trivial case, let’s count the number of
nodes in the tree:</p>
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="gp">In [5]: </span><span class="n">fn</span> <span class="o">=</span> <span class="k">lambda</span> <span class="n">n</span><span class="p">,</span> <span class="o">*</span><span class="n">c</span><span class="p">:</span> <span class="nb">sum</span><span class="p">(</span><span class="n">c</span><span class="p">)</span> <span class="o">+</span> <span class="mi">1</span>

<span class="gp">In [6]: </span><span class="n">postvisitor</span><span class="p">(</span><span class="n">tree</span><span class="p">,</span> <span class="n">fn</span><span class="p">)</span>
<span class="gh">Out[6]: </span><span class="go">7</span>
</pre></div>
</div>
<p>This time the visitor <a class="reference external" href="https://docs.python.org/3/library/functions.html#sum" title="(in Python v3.10)"><code class="xref py py-func docutils literal notranslate"><span class="pre">sums</span></code></a> the results from its children, and adds
one for itself.</p>
<p>What about preorder traversal? This time we need a little more code (not much)
as <a class="reference internal" href="#preorder-recursive"><span class="std std-numref">Listing 9.5</span></a> shows.</p>
<div class="literal-block-wrapper docutils container" id="id17">
<span id="preorder-recursive"></span><div class="code-block-caption"><span class="caption-number">Listing 9.5 </span><span class="caption-text">The simple preorder visitor from
<a class="reference internal" href="example_code.html#example_code.graphs.previsitor" title="example_code.graphs.previsitor"><code class="xref py py-func docutils literal notranslate"><span class="pre">example_code.graphs.previsitor()</span></code></a>.</span><a class="headerlink" href="#id17" title="Permalink to this code">¶</a></div>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="linenos"> 1</span><span class="k">def</span> <span class="nf">previsitor</span><span class="p">(</span><span class="n">tree</span><span class="p">,</span> <span class="n">fn</span><span class="p">,</span> <span class="n">fn_parent</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
<span class="linenos"> 2</span>    <span class="sd">&quot;&quot;&quot;Traverse tree in preorder applying a function to every node.</span>
<span class="linenos"> 3</span>
<span class="linenos"> 4</span><span class="sd">    Parameters</span>
<span class="linenos"> 5</span><span class="sd">    ----------</span>
<span class="linenos"> 6</span><span class="sd">    tree: TreeNode</span>
<span class="linenos"> 7</span><span class="sd">        The tree to be visited.</span>
<span class="linenos"> 8</span><span class="sd">    fn: function(node, fn_parent)</span>
<span class="linenos"> 9</span><span class="sd">        A function to be applied at each node. The function should take the</span>
<span class="linenos">10</span><span class="sd">        node to be visited as its first argument, and the result of visiting</span>
<span class="linenos">11</span><span class="sd">        its parent as the second.</span>
<span class="linenos">12</span><span class="sd">    &quot;&quot;&quot;</span>
<span class="linenos">13</span>    <span class="n">fn_out</span> <span class="o">=</span> <span class="n">fn</span><span class="p">(</span><span class="n">tree</span><span class="p">,</span> <span class="n">fn_parent</span><span class="p">)</span>
<span class="linenos">14</span>
<span class="linenos">15</span>    <span class="k">for</span> <span class="n">child</span> <span class="ow">in</span> <span class="n">tree</span><span class="o">.</span><span class="n">children</span><span class="p">:</span>
<span class="linenos">16</span>        <span class="n">previsitor</span><span class="p">(</span><span class="n">child</span><span class="p">,</span> <span class="n">fn</span><span class="p">,</span> <span class="n">fn_out</span><span class="p">)</span>
</pre></div>
</div>
</div>
<p>What can we do with a preorder traversal? Well one thing is that we can measure
the depth in the tree of every node:</p>
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="gp">In [7]: </span><span class="kn">from</span> <span class="nn">example_code.graphs</span> <span class="kn">import</span> <span class="n">previsitor</span>

<span class="gp">In [8]: </span><span class="k">def</span> <span class="nf">fn</span><span class="p">(</span><span class="n">node</span><span class="p">,</span> <span class="n">p</span><span class="p">):</span>
<span class="gp">   ...: </span>    <span class="n">depth</span> <span class="o">=</span> <span class="n">p</span> <span class="o">+</span> <span class="mi">1</span> <span class="k">if</span> <span class="n">p</span> <span class="k">else</span> <span class="mi">1</span>
<span class="gp">   ...: </span>    <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">node</span><span class="o">.</span><span class="n">value</span><span class="si">}</span><span class="s2">: </span><span class="si">{</span><span class="n">depth</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
<span class="gp">   ...: </span>    <span class="k">return</span> <span class="n">depth</span>
<span class="gp">   ...:</span>

<span class="gp">In [9]: </span><span class="n">previsitor</span><span class="p">(</span><span class="n">tree</span><span class="p">,</span> <span class="n">fn</span><span class="p">)</span>
<span class="go">a: 1</span>
<span class="go">b: 2</span>
<span class="go">d: 3</span>
<span class="go">e: 3</span>
<span class="go">f: 3</span>
<span class="go">c: 2</span>
<span class="go">g: 3</span>
</pre></div>
</div>
<p>Observe here that the node visitor order is different from the postvisitor, and
that we successfully diagnosed the depth of each node.</p>
</section>
</section>
<section id="expression-trees">
<span id="expr-trees"></span><h2><span class="section-number">9.4. </span>Expression trees<a class="headerlink" href="#expression-trees" title="Permalink to this headline">¶</a></h2>
<p>One important application of trees is in representing arithmetic expressions.
Consider the expression <span class="math notranslate nohighlight">\(2y + 4^{(5 + x)}\)</span>. Suppose, further, that
we want to represent this on a computer in such a way that we can perform
mathematical operations: evaluation, differentiation, expansion, and
simplification. How would we do this? Well, thanks to the rules for order of
operations, this expression forms a hierarchy from the operators to be evaluated
first, down to the last one. <a class="reference internal" href="#expr-tree"><span class="std std-numref">Fig. 9.5</span></a> shows a tree representation for
our mathematical expression. The evaluation rule for trees of this type is a
postorder traversal, first the leaf nodes are evaluated, then their parents and
so on up until finally the addition at the root node is evaluated.</p>
<figure class="align-default" id="id18">
<span id="expr-tree"></span><div class="graphviz"><object data="_images/graphviz-b42423cc23f866b187c4c1bb94a86a9c8c740c8e.svg" type="image/svg+xml" class="graphviz">
<p class="warning">strict digraph{
    a [label=&quot;+&quot;];
    b [label=&quot;⨉&quot;];
    c [label=&quot;^&quot;];
    2;
    y [font=&quot;italic&quot;];
    a-&gt;b
    a-&gt;c
    b-&gt;{2 y}
    c-&gt;4
    d[label=&quot;+&quot;]
    c-&gt;d
    d-&gt;5
    x [font=&quot;italic&quot;]
    d-&gt;x
}</p></object></div>
<figcaption>
<p><span class="caption-number">Fig. 9.5 </span><span class="caption-text">Expression tree for the expression <span class="math notranslate nohighlight">\(2y + 4^{(5 + x)}\)</span>.</span><a class="headerlink" href="#id18" title="Permalink to this image">¶</a></p>
</figcaption>
</figure>
<p>We will first consider how to construct trees like this, then consider the
question of the operations we could implement on them.</p>
<section id="an-expression-tree-class-hierarchy">
<span id="expr-hierarchy"></span><h3><span class="section-number">9.4.1. </span>An expression tree class hierarchy<a class="headerlink" href="#an-expression-tree-class-hierarchy" title="Permalink to this headline">¶</a></h3>
<p>The nodes of an expression tree don’t just have different values, they have
different <a class="reference internal" href="3_objects.html#term-type"><span class="xref std std-term">type</span></a>. That is to say, the meaning of operations changes
between, say <span class="math notranslate nohighlight">\(+\)</span> and <span class="math notranslate nohighlight">\(2\)</span>. For example the evaluation rule for these
nodes will be different, as will the differentiation rule. At the same time, all
the nodes are still expressions and will share many common features. This is a
textbook case of inheritance. There should be a most general class, covering all
types of expression nodes, and then more specialised node types should inherit
from this. The most basic distinction is between <em>operators</em>, which have at least
one operand (represented by a child node), and <em>terminals</em>, which have no
children. In practice, it will result in simpler, more elegant code if terminals
actually have an empty tuple of operands rather than none at all. This
facilitates writing, for example, tree visitors which loop over all of the
children of a node.</p>
<figure class="align-default" id="id19">
<div class="graphviz"><object data="_images/graphviz-bda78bed7d103c39788a58acc96f13de9cbf6d96.svg" type="image/svg+xml" class="graphviz">
<p class="warning">strict digraph{
    node [
        shape = &quot;record&quot;
        ]

    edge [
        arrowtail = &quot;empty&quot;;
        dir = &quot;back&quot;;
        ]

    Expression -&gt; Terminal
    Terminal -&gt; Number
    Terminal -&gt; Symbol

    Expression -&gt; Operator
    Operator -&gt; Add
    Operator -&gt; Mul
    Operator -&gt; Sub
    Operator -&gt; Div
    Operator -&gt; Pow
}</p></object></div>
<figcaption>
<p><span class="caption-number">Fig. 9.6 </span><span class="caption-text">Inheritance diagram for a very basic symbolic language. Each box
represents a class, with the arrows showing inheritance relationships. Note that
the edges in such diagrams conventionally point from the child class to the
parent class, because it’s the child class that refers to the parent. The
parent does not refer to the child.</span><a class="headerlink" href="#id19" title="Permalink to this image">¶</a></p>
</figcaption>
</figure>
<p>Let’s consider what would be needed at each layer of the hierarchy.
<code class="xref py py-class docutils literal notranslate"><span class="pre">Expression</span></code> should implement everything that is the same for all nodes. What
will that comprise?</p>
<dl>
<dt><code class="xref py py-meth docutils literal notranslate"><span class="pre">__init__()</span></code></dt><dd><p>The constructor will take a <a class="reference external" href="https://docs.python.org/3/library/stdtypes.html#tuple" title="(in Python v3.10)"><code class="xref py py-class docutils literal notranslate"><span class="pre">tuple</span></code></a> of operands, since every
expression has operands (even if terminals have zero operands).</p>
</dd>
<dt><a class="reference external" href="https://docs.python.org/3/reference/datamodel.html#object.__add__" title="(in Python v3.10)"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__add__()</span></code></a>, <a class="reference external" href="https://docs.python.org/3/reference/datamodel.html#object.__sub__" title="(in Python v3.10)"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__sub__()</span></code></a>, <a class="reference external" href="https://docs.python.org/3/reference/datamodel.html#object.__mul__" title="(in Python v3.10)"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__mul__()</span></code></a>, <a class="reference external" href="https://docs.python.org/3/reference/datamodel.html#object.__truediv__" title="(in Python v3.10)"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__truediv__()</span></code></a>, <a class="reference external" href="https://docs.python.org/3/reference/datamodel.html#object.__pow__" title="(in Python v3.10)"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__pow__()</span></code></a></dt><dd><p>Implementing the <a class="reference internal" href="3_objects.html#term-special-method"><span class="xref std std-term">special methods</span></a> for arithmetic is
necessary for expressions to exhibit the correct symbolic mathematical
behaviour. We met this idea already in <a class="reference internal" href="3_objects.html#object-arithmetic"><span class="std std-numref">Section 3.3.6</span></a>.
Arithmetic operations involving symbolic expressions return other symbolic
expressions. For example if <code class="xref py py-obj docutils literal notranslate"><span class="pre">a</span></code> and <code class="xref py py-obj docutils literal notranslate"><span class="pre">b</span></code> are expressions then <code class="xref py py-obj docutils literal notranslate"><span class="pre">a</span> <span class="pre">+</span> <span class="pre">b</span></code> is
simply <code class="xref py py-obj docutils literal notranslate"><span class="pre">Add(a,</span> <span class="pre">b)</span></code>. The fact that these rules are the same for all
expressions indicates that they should be implemented on the base class
<code class="xref py py-class docutils literal notranslate"><span class="pre">Expression</span></code>.</p>
<p>Just as was the case when we implemented the
<a class="reference internal" href="example_code.html#example_code.polynomial.Polynomial" title="example_code.polynomial.Polynomial"><code class="xref py py-class docutils literal notranslate"><span class="pre">Polynomial</span></code></a> class, it will be necessary to
do something special when one of the operands is a number. In this case, the
right thing to do is to turn the number into an expression by instantiating a
<code class="xref py py-class docutils literal notranslate"><span class="pre">Number</span></code> with it as a value. Once this has been done, the number is
just another <code class="xref py py-class docutils literal notranslate"><span class="pre">Expression</span></code> obeying the same arithmetic rules as other
expressions. The need to accommodate operations between symbolic expressions
and numbers also implies that it will also be necessary to implement the
<a class="reference internal" href="3_objects.html#term-special-method"><span class="xref std std-term">special methods</span></a> for reversed arithmetic operations.</p>
</dd>
</dl>
<p>Let’s now consider <code class="xref py py-class docutils literal notranslate"><span class="pre">Operator</span></code>. The operations for creating string
representations can be implemented here, because they will be the same for all
operators but different for terminals.</p>
<dl>
<dt><a class="reference external" href="https://docs.python.org/3/reference/datamodel.html#object.__repr__" title="(in Python v3.10)"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__repr__()</span></code></a></dt><dd><p>Remember that this is the canonical string representation, and is usually
the code that could be passed to the <a class="reference internal" href="2_programs_in_files.html#term-Python-interpreter"><span class="xref std std-term">Python interpreter</span></a> to construct
the object. Something like the following would work:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="fm">__repr__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
    <span class="k">return</span> <span class="nb">type</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="vm">__name__</span> <span class="o">+</span> <span class="nb">repr</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">operands</span><span class="p">)</span>
</pre></div>
</div>
<p>This approch is valid because the string representation of a <a class="reference external" href="https://docs.python.org/3/library/stdtypes.html#tuple" title="(in Python v3.10)"><code class="xref py py-class docutils literal notranslate"><span class="pre">tuple</span></code></a>
is a pair of round brackets containing the string representation of each
item in the tuple.</p>
</dd>
<dt><a class="reference external" href="https://docs.python.org/3/reference/datamodel.html#object.__str__" title="(in Python v3.10)"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__str__()</span></code></a></dt><dd><p>This is the human-readable string output, using <a class="reference internal" href="3_objects.html#term-infix-operator"><span class="xref std std-term">infix operators</span></a>, so in the example above we would expect to see
<code class="xref py py-obj docutils literal notranslate"><span class="pre">2</span> <span class="pre">*</span> <span class="pre">y</span> <span class="pre">+</span> <span class="pre">4</span> <span class="pre">^</span> <span class="pre">(5</span> <span class="pre">+</span> <span class="pre">x)</span></code> This looks sort of straightforward, simply associate the correct
symbol with each operator class as a <a class="reference internal" href="8_inheritance.html#term-class-attribute"><span class="xref std std-term">class attribute</span></a> and place the
string representation of the operands on either side.</p>
<p>The challenge is to correctly include the brackets. In order to do this, it
is necessary to associate with every expression class a <a class="reference internal" href="8_inheritance.html#term-class-attribute"><span class="xref std std-term">class
attribute</span></a> whose value is a number giving an operator precedence to that
class. For example, the precedence of <code class="xref py py-class docutils literal notranslate"><span class="pre">Mul</span></code> should be higher than
<code class="xref py py-class docutils literal notranslate"><span class="pre">Add</span></code>. A full list of operators in precedence order is available in
<a class="reference external" href="https://docs.python.org/3/reference/expressions.html#operator-summary" title="(in Python v3.10)"><span class="xref std std-ref">the official Python documentation</span></a>. An operand
<span class="math notranslate nohighlight">\(a\)</span> of an operator <span class="math notranslate nohighlight">\(o\)</span> needs to be placed in brackets if the
precedence of <span class="math notranslate nohighlight">\(a\)</span> is lower than the precedence of <span class="math notranslate nohighlight">\(o\)</span>.</p>
</dd>
</dl>
<p>Individual operator classes therefore need to define very little, just two
<a class="reference internal" href="8_inheritance.html#term-class-attribute"><span class="xref std std-term">class attributes</span></a>, one for the operator precedence, and
one to set the symbol when printing the operator.</p>
<p>Let’s now consider <code class="xref py py-class docutils literal notranslate"><span class="pre">Terminal</span></code>. What does it need to set?</p>
<dl class="simple">
<dt><a class="reference external" href="https://docs.python.org/3/reference/datamodel.html#object.__init__" title="(in Python v3.10)"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__init__()</span></code></a></dt><dd><p>The <a class="reference internal" href="3_objects.html#term-constructor"><span class="xref std std-term">constructor</span></a> for <code class="xref py py-class docutils literal notranslate"><span class="pre">Expression</span></code> assumes that an expression is
defined by a series of operands. Terminals have an empty list of operands
but do have something that other expressions lack, a value. In the case of
<code class="xref py py-class docutils literal notranslate"><span class="pre">Number</span></code>, this is a number, while for <code class="xref py py-class docutils literal notranslate"><span class="pre">Symbol</span></code> the value is a
string (usually a single character). <code class="xref py py-class docutils literal notranslate"><span class="pre">Terminal</span></code> therefore needs its
own <code class="xref py py-meth docutils literal notranslate"><span class="pre">__init__()</span></code> which will take a value argument.
<code class="xref py py-class docutils literal notranslate"><span class="pre">Terminal.__init__</span></code> still has to call the <a class="reference internal" href="8_inheritance.html#term-superclass"><span class="xref std std-term">superclass</span></a>
constructor in order to ensure that the operands tuple is initialised.</p>
</dd>
<dt><a class="reference external" href="https://docs.python.org/3/reference/datamodel.html#object.__repr__" title="(in Python v3.10)"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__repr__()</span></code></a> and <a class="reference external" href="https://docs.python.org/3/reference/datamodel.html#object.__str__" title="(in Python v3.10)"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__str__()</span></code></a></dt><dd><p>The string representations of <code class="xref py py-class docutils literal notranslate"><span class="pre">Terminal</span></code> are straightforward, simply
return <code class="xref py py-obj docutils literal notranslate"><span class="pre">repr(self.value)</span></code> and <code class="xref py py-obj docutils literal notranslate"><span class="pre">str(self.value)</span></code> respectively. Note that in
order for  <code class="xref py py-meth docutils literal notranslate"><span class="pre">Operator.__str__()</span></code> to function correctly, <code class="xref py py-class docutils literal notranslate"><span class="pre">Terminal</span></code>
will need to advertise its operator precedence. The reader should think
carefully about what the precedence of a <code class="xref py py-class docutils literal notranslate"><span class="pre">Terminal</span></code> should be.</p>
</dd>
</dl>
<p>The two <code class="xref py py-class docutils literal notranslate"><span class="pre">Terminal</span></code> subclasses need to do very little other than identify
themselves. The only functionality they might provide would be to override
<a class="reference external" href="https://docs.python.org/3/reference/datamodel.html#object.__init__" title="(in Python v3.10)"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__init__()</span></code></a> to check that their value is a <a class="reference external" href="https://docs.python.org/3/library/numbers.html#numbers.Number" title="(in Python v3.10)"><code class="xref py py-class docutils literal notranslate"><span class="pre">numbers.Number</span></code></a>
in the case of <code class="xref py py-class docutils literal notranslate"><span class="pre">Number</span></code> and a <a class="reference external" href="https://docs.python.org/3/library/stdtypes.html#str" title="(in Python v3.10)"><code class="xref py py-class docutils literal notranslate"><span class="pre">str</span></code></a> in the case of <code class="xref py py-class docutils literal notranslate"><span class="pre">Symbol</span></code>.</p>
</section>
<section id="operations-on-expression-trees">
<h3><span class="section-number">9.4.2. </span>Operations on expression trees<a class="headerlink" href="#operations-on-expression-trees" title="Permalink to this headline">¶</a></h3>
<details class="sphinx-bs dropdown card mb-3">
<summary class="summary-title card-header">
Video: evaluating expressions.<div class="summary-down docutils">
<svg version="1.1" width="24" height="24" class="octicon octicon-chevron-down" viewBox="0 0 24 24" aria-hidden="true"><path fill-rule="evenodd" d="M5.22 8.72a.75.75 0 000 1.06l6.25 6.25a.75.75 0 001.06 0l6.25-6.25a.75.75 0 00-1.06-1.06L12 14.44 6.28 8.72a.75.75 0 00-1.06 0z"></path></svg></div>
<div class="summary-up docutils">
<svg version="1.1" width="24" height="24" class="octicon octicon-chevron-up" viewBox="0 0 24 24" aria-hidden="true"><path fill-rule="evenodd" d="M18.78 15.28a.75.75 0 000-1.06l-6.25-6.25a.75.75 0 00-1.06 0l-6.25 6.25a.75.75 0 101.06 1.06L12 9.56l5.72 5.72a.75.75 0 001.06 0z"></path></svg></div>
</summary><div class="summary-content card-body docutils">
<div class="vimeo docutils container">
<iframe src="https://player.vimeo.com/video/523478799"
frameborder="0" allow="autoplay; fullscreen"
allowfullscreen></iframe></div>
</div>
</details><p>Many operations on expression trees can be implemented using tree visitors, most
frequently by visiting the tree in postorder. An example is
expression evaluation. The user provides a <a class="reference external" href="https://docs.python.org/3/library/stdtypes.html#dict" title="(in Python v3.10)"><code class="xref py py-class docutils literal notranslate"><span class="pre">dict</span></code></a> mapping symbol names to
numerical values, and we proceed from leaf nodes upwards. Every <code class="xref py py-class docutils literal notranslate"><span class="pre">Symbol</span></code>
is replaced by a numerical value from the dictionary, every <code class="xref py py-class docutils literal notranslate"><span class="pre">Number</span></code>
stands for itself, and every <code class="xref py py-class docutils literal notranslate"><span class="pre">Operator</span></code> performs the appropriate
computation on its operands (which are now guaranteed to be numbers).</p>
<p>The leaf-first order of execution makes this a postorder tree visitor, but what
is the visitor function? It seems we need a different function for every
<a class="reference external" href="https://docs.python.org/3/library/functions.html#type" title="(in Python v3.10)"><code class="xref py py-class docutils literal notranslate"><span class="pre">type</span></code></a> of expression node we encounter. It turns out that this is exactly
what is required, and Python provides this functionality in the form of the
single dispatch function.</p>
</section>
<section id="single-dispatch-functions">
<h3><span class="section-number">9.4.3. </span>Single dispatch functions<a class="headerlink" href="#single-dispatch-functions" title="Permalink to this headline">¶</a></h3>
<p>In all of the cases we have encountered so far, there is a unique mapping from
the name of a function to the code implementing that function. That is, no
matter what arguments are passed to a function, the same code will execute (so
long as the right number of arguments are passed). A single dispatch function is
not like this. Instead, calling a single function name causes different function
code to execute, depending on the type of the first argument <a class="footnote-reference brackets" href="#single" id="id3">3</a>.</p>
<div class="literal-block-wrapper docutils container" id="id20">
<span id="tree-evaluate"></span><div class="code-block-caption"><span class="caption-number">Listing 9.6 </span><span class="caption-text">A <a class="reference internal" href="#term-single-dispatch-function"><span class="xref std std-term">single dispatch function</span></a> implementing the evaluation of
a single <code class="xref py py-class docutils literal notranslate"><span class="pre">Expression</span></code> node. The implementation of the expressions
language itself, in the <code class="xref py py-mod docutils literal notranslate"><span class="pre">expressions</span></code> module is <a class="reference internal" href="#ex-expr"><span class="std std-ref">left as an
exercise</span></a>.</span><a class="headerlink" href="#id20" title="Permalink to this code">¶</a></div>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="linenos"> 1</span><span class="kn">from</span> <span class="nn">functools</span> <span class="kn">import</span> <span class="n">singledispatch</span>
<span class="linenos"> 2</span><span class="kn">import</span> <span class="nn">expressions</span>
<span class="linenos"> 3</span>
<span class="linenos"> 4</span>
<span class="linenos"> 5</span><span class="nd">@singledispatch</span>
<span class="linenos"> 6</span><span class="k">def</span> <span class="nf">evaluate</span><span class="p">(</span><span class="n">expr</span><span class="p">,</span> <span class="o">*</span><span class="n">o</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
<span class="linenos"> 7</span>    <span class="sd">&quot;&quot;&quot;Evaluate an expression node.</span>
<span class="linenos"> 8</span>
<span class="linenos"> 9</span><span class="sd">    Parameters</span>
<span class="linenos">10</span><span class="sd">    ----------</span>
<span class="linenos">11</span><span class="sd">    expr: Expression</span>
<span class="linenos">12</span><span class="sd">        The expression node to be evaluated.</span>
<span class="linenos">13</span><span class="sd">    *o: numbers.Number</span>
<span class="linenos">14</span><span class="sd">        The results of evaluating the operands of expr.</span>
<span class="linenos">15</span><span class="sd">    **kwargs:</span>
<span class="linenos">16</span><span class="sd">        Any keyword arguments required to evaluate specific types of expression.</span>
<span class="linenos">17</span><span class="sd">    symbol_map: dict</span>
<span class="linenos">18</span><span class="sd">        A dictionary mapping Symbol names to numerical values, for example:</span>
<span class="linenos">19</span>
<span class="linenos">20</span><span class="sd">        {&#39;x&#39;: 1}</span>
<span class="linenos">21</span><span class="sd">    &quot;&quot;&quot;</span>
<span class="linenos">22</span>    <span class="k">raise</span> <span class="ne">NotImplementedError</span><span class="p">(</span>
<span class="linenos">23</span>        <span class="sa">f</span><span class="s2">&quot;Cannot evaluate a </span><span class="si">{</span><span class="nb">type</span><span class="p">(</span><span class="n">expr</span><span class="p">)</span><span class="o">.</span><span class="vm">__name__</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
<span class="linenos">24</span>
<span class="linenos">25</span>
<span class="linenos">26</span><span class="nd">@evaluate</span><span class="o">.</span><span class="n">register</span><span class="p">(</span><span class="n">expressions</span><span class="o">.</span><span class="n">Number</span><span class="p">)</span>
<span class="linenos">27</span><span class="k">def</span> <span class="nf">_</span><span class="p">(</span><span class="n">expr</span><span class="p">,</span> <span class="o">*</span><span class="n">o</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
<span class="linenos">28</span>    <span class="k">return</span> <span class="n">expr</span><span class="o">.</span><span class="n">value</span>
<span class="linenos">29</span>
<span class="linenos">30</span>
<span class="linenos">31</span><span class="nd">@evaluate</span><span class="o">.</span><span class="n">register</span><span class="p">(</span><span class="n">expressions</span><span class="o">.</span><span class="n">Symbol</span><span class="p">)</span>
<span class="linenos">32</span><span class="k">def</span> <span class="nf">_</span><span class="p">(</span><span class="n">expr</span><span class="p">,</span> <span class="o">*</span><span class="n">o</span><span class="p">,</span> <span class="n">symbol_map</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
<span class="linenos">33</span>    <span class="k">return</span> <span class="n">symbol_map</span><span class="p">[</span><span class="n">expr</span><span class="o">.</span><span class="n">value</span><span class="p">]</span>
<span class="linenos">34</span>
<span class="linenos">35</span>
<span class="linenos">36</span><span class="nd">@evaluate</span><span class="o">.</span><span class="n">register</span><span class="p">(</span><span class="n">expressions</span><span class="o">.</span><span class="n">Add</span><span class="p">)</span>
<span class="linenos">37</span><span class="k">def</span> <span class="nf">_</span><span class="p">(</span><span class="n">expr</span><span class="p">,</span> <span class="o">*</span><span class="n">o</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
<span class="linenos">38</span>    <span class="k">return</span> <span class="n">o</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">+</span> <span class="n">o</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
<span class="linenos">39</span>
<span class="linenos">40</span>
<span class="linenos">41</span><span class="nd">@evaluate</span><span class="o">.</span><span class="n">register</span><span class="p">(</span><span class="n">expressions</span><span class="o">.</span><span class="n">Sub</span><span class="p">)</span>
<span class="linenos">42</span><span class="k">def</span> <span class="nf">_</span><span class="p">(</span><span class="n">expr</span><span class="p">,</span> <span class="o">*</span><span class="n">o</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
<span class="linenos">43</span>    <span class="k">return</span> <span class="n">o</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">-</span> <span class="n">o</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
<span class="linenos">44</span>
<span class="linenos">45</span>
<span class="linenos">46</span><span class="nd">@evaluate</span><span class="o">.</span><span class="n">register</span><span class="p">(</span><span class="n">expressions</span><span class="o">.</span><span class="n">Mul</span><span class="p">)</span>
<span class="linenos">47</span><span class="k">def</span> <span class="nf">_</span><span class="p">(</span><span class="n">expr</span><span class="p">,</span> <span class="o">*</span><span class="n">o</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
<span class="linenos">48</span>    <span class="k">return</span> <span class="n">o</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">*</span> <span class="n">o</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
<span class="linenos">49</span>
<span class="linenos">50</span>
<span class="linenos">51</span><span class="nd">@evaluate</span><span class="o">.</span><span class="n">register</span><span class="p">(</span><span class="n">expressions</span><span class="o">.</span><span class="n">Div</span><span class="p">)</span>
<span class="linenos">52</span><span class="k">def</span> <span class="nf">_</span><span class="p">(</span><span class="n">expr</span><span class="p">,</span> <span class="o">*</span><span class="n">o</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
<span class="linenos">53</span>    <span class="k">return</span> <span class="n">o</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">/</span> <span class="n">o</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
<span class="linenos">54</span>
<span class="linenos">55</span>
<span class="linenos">56</span><span class="nd">@evaluate</span><span class="o">.</span><span class="n">register</span><span class="p">(</span><span class="n">expressions</span><span class="o">.</span><span class="n">Pow</span><span class="p">)</span>
<span class="linenos">57</span><span class="k">def</span> <span class="nf">_</span><span class="p">(</span><span class="n">expr</span><span class="p">,</span> <span class="o">*</span><span class="n">o</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
<span class="linenos">58</span>    <span class="k">return</span> <span class="n">o</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">**</span> <span class="n">o</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
</pre></div>
</div>
</div>
<p><a class="reference internal" href="#tree-evaluate"><span class="std std-numref">Listing 9.6</span></a> shows a single dispatch function for a visitor function
which evaluates a <code class="xref py py-class docutils literal notranslate"><span class="pre">Expression</span></code>. Start with lines 6-19. These define a
function <code class="xref py py-func docutils literal notranslate"><span class="pre">evaluate()</span></code> which will be used in
the default case, that is, in the case where the <a class="reference external" href="https://docs.python.org/3/library/functions.html#type" title="(in Python v3.10)"><code class="xref py py-class docutils literal notranslate"><span class="pre">type</span></code></a> of the first
argument doesn’t match any of the other implementations of
<code class="xref py py-func docutils literal notranslate"><span class="pre">evaluate()</span></code>. In this case, the first
argument is the expression that we’re evaluating, so if the type doesn’t match
then this means that we don’t know how to evaluate this object, and the only
course of action available is to throw an <a class="reference internal" href="6_exceptions.html#term-exception"><span class="xref std std-term">exception</span></a>.</p>
<p>The new feature that we haven’t met before appears on line 5.
<a class="reference external" href="https://docs.python.org/3/library/functools.html#functools.singledispatch" title="(in Python v3.10)"><code class="xref py py-func docutils literal notranslate"><span class="pre">functools.singledispatch()</span></code></a> turns a function into
a single dispatch function. The <code class="xref py py-obj docutils literal notranslate"><span class="pre">&#64;</span></code> symbol marks
<a class="reference external" href="https://docs.python.org/3/library/functools.html#functools.singledispatch" title="(in Python v3.10)"><code class="xref py py-func docutils literal notranslate"><span class="pre">singledispatch()</span></code></a> as a <a class="reference internal" href="11_further_object-oriented_features.html#term-decorator"><span class="xref std std-term">decorator</span></a>. We’ll return to them
in <code class="xref std std-numref docutils literal notranslate"><span class="pre">decorators</span></code>. For the moment, we just need to know that
<code class="xref py py-obj docutils literal notranslate"><span class="pre">&#64;singledispatch</span></code> turns the function it precedes into a single dispatch
function.</p>
<p>Next we turn our attention to the implementation of evaluation for the different
expression types. Look first at lines 26-28, which provide the evaluation of
<code class="xref py py-class docutils literal notranslate"><span class="pre">Number</span></code> nodes. The function body is trivial: the evaluation of a
<code class="xref py py-class docutils literal notranslate"><span class="pre">Number</span></code> is simply its value. The function interface is more interesting.
Notice that the function name is given as <code class="xref py py-obj docutils literal notranslate"><span class="pre">_</span></code>. This is the Python convention for
a name which will never be used. This function will never be called by its
declared name. Instead, look at the decorator on line 26. The single dispatch
function <code class="xref py py-func docutils literal notranslate"><span class="pre">evaluate()</span></code> has a <a class="reference internal" href="3_objects.html#term-method"><span class="xref std std-term">method</span></a>
<code class="xref py py-meth docutils literal notranslate"><span class="pre">register()</span></code>. When used as a decorator, the <code class="xref py py-meth docutils literal notranslate"><span class="pre">register()</span></code> method of a
single dispatch function registers the function that follows as implementation
for the <a class="reference external" href="https://docs.python.org/3/reference/compound_stmts.html#class" title="(in Python v3.10)"><code class="xref std std-keyword docutils literal notranslate"><span class="pre">class</span></code></a> given as an argument to <code class="xref py py-meth docutils literal notranslate"><span class="pre">register()</span></code>. On this
occasion, this is <code class="xref py py-class docutils literal notranslate"><span class="pre">expressions.Number</span></code>.</p>
<p>Now look at lines 31-33. These contain the implementation of
<code class="xref py py-func docutils literal notranslate"><span class="pre">evaluate()</span></code> for <code class="xref py py-class docutils literal notranslate"><span class="pre">expressions.Symbol</span></code>.
In order to evaluate a symbol, we depend on the mapping from symbol names to
numerical values that has been passed in.</p>
<p>Finally, look at lines 36-38. These define the evaluation visitor for addition.
This works simply by adding the results of evaluating the two operands of
<code class="xref py py-class docutils literal notranslate"><span class="pre">expressions.Add</span></code>. The evaluation visitors for the other operators follow
<em>mutatis mutandis</em>.</p>
</section>
<section id="an-expanded-tree-visitor">
<h3><span class="section-number">9.4.4. </span>An expanded tree visitor<a class="headerlink" href="#an-expanded-tree-visitor" title="Permalink to this headline">¶</a></h3>
<p>The need to provide the <code class="xref py py-obj docutils literal notranslate"><span class="pre">symbol_map</span></code> parameter to the
<code class="xref py py-class docutils literal notranslate"><span class="pre">expressions.Symbol</span></code> evaluation visitor means that the postorder visitor
in <a class="reference internal" href="#postorder-recursive"><span class="std std-numref">Listing 9.4</span></a> is not quite up to the task.
<a class="reference internal" href="#postorder-recursive-kwargs"><span class="std std-numref">Listing 9.7</span></a> extends the tree visitor to pass arbitrary
keyword arguments through to the visitor function.</p>
<div class="literal-block-wrapper docutils container" id="id21">
<span id="postorder-recursive-kwargs"></span><div class="code-block-caption"><span class="caption-number">Listing 9.7 </span><span class="caption-text">A recursive tree visitor that passes any keyword arguments
through to the visitor function. This is available as
<code class="xref py py-func docutils literal notranslate"><span class="pre">example_code.expression_tools.post_visitor()</span></code>. We also account
for the name changes between <a class="reference internal" href="example_code.html#example_code.graphs.TreeNode" title="example_code.graphs.TreeNode"><code class="xref py py-class docutils literal notranslate"><span class="pre">TreeNode</span></code></a>
and <code class="xref py py-class docutils literal notranslate"><span class="pre">Expression</span></code>.</span><a class="headerlink" href="#id21" title="Permalink to this code">¶</a></div>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="linenos"> 1</span><span class="k">def</span> <span class="nf">postvisitor</span><span class="p">(</span><span class="n">expr</span><span class="p">,</span> <span class="n">fn</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
<span class="linenos"> 2</span>    <span class="sd">&#39;&#39;&#39;Traverse an Expression in postorder applying a function to every node.</span>
<span class="linenos"> 3</span>
<span class="linenos"> 4</span><span class="sd">    Parameters</span>
<span class="linenos"> 5</span><span class="sd">    ----------</span>
<span class="linenos"> 6</span><span class="sd">    expr: Expression</span>
<span class="linenos"> 7</span><span class="sd">        The expression to be visited.</span>
<span class="linenos"> 8</span><span class="sd">    fn: function(node, *o, **kwargs)</span>
<span class="linenos"> 9</span><span class="sd">        A function to be applied at each node. The function should take the</span>
<span class="linenos">10</span><span class="sd">        node to be visited as its first argument, and the results of visiting</span>
<span class="linenos">11</span><span class="sd">        its operands as any further positional arguments. Any additional</span>
<span class="linenos">12</span><span class="sd">        information that the visitor requires can be passed in as keyword</span>
<span class="linenos">13</span><span class="sd">        arguments.</span>
<span class="linenos">14</span><span class="sd">    **kwargs:</span>
<span class="linenos">15</span><span class="sd">        Any additional keyword arguments to be passed to fn.</span>
<span class="linenos">16</span><span class="sd">    &#39;&#39;&#39;</span>
<span class="linenos">17</span>    <span class="k">return</span> <span class="n">fn</span><span class="p">(</span><span class="n">expr</span><span class="p">,</span>
<span class="linenos">18</span>              <span class="o">*</span><span class="p">(</span><span class="n">postvisitor</span><span class="p">(</span><span class="n">c</span><span class="p">,</span> <span class="n">fn</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span> <span class="k">for</span> <span class="n">c</span> <span class="ow">in</span> <span class="n">expr</span><span class="o">.</span><span class="n">operands</span><span class="p">),</span>
<span class="linenos">19</span>              <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
</pre></div>
</div>
</div>
<p>Assuming we have an implementation of our simple expression language, we are now
in a position to try out our expression evaluator:</p>
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="gp">In [1]: </span><span class="kn">from</span> <span class="nn">expressions</span> <span class="kn">import</span> <span class="n">Symbol</span>

<span class="gp">In [2]: </span><span class="kn">from</span> <span class="nn">example_code.expression_tools</span> <span class="kn">import</span> <span class="n">evaluate</span><span class="p">,</span> <span class="n">postvisitor</span>

<span class="gp">In [3]: </span><span class="n">x</span> <span class="o">=</span> <span class="n">Symbol</span><span class="p">(</span><span class="s1">&#39;x&#39;</span><span class="p">)</span>

<span class="gp">In [4]: </span><span class="n">y</span> <span class="o">=</span> <span class="n">Symbol</span><span class="p">(</span><span class="s1">&#39;y&#39;</span><span class="p">)</span>

<span class="gp">In [5]: </span><span class="n">expr</span> <span class="o">=</span> <span class="mi">3</span><span class="o">*</span><span class="n">x</span> <span class="o">+</span> <span class="mi">2</span><span class="o">**</span><span class="p">(</span><span class="n">y</span><span class="o">/</span><span class="mi">5</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span>

<span class="gp">In [6]: </span><span class="nb">print</span><span class="p">(</span><span class="n">expr</span><span class="p">)</span>
<span class="go">3 ⨉ x + 2 ^ (y / 5) - 1</span>

<span class="gp">In [7]: </span><span class="n">postvisitor</span><span class="p">(</span><span class="n">expr</span><span class="p">,</span> <span class="n">evaluate</span><span class="p">,</span> <span class="n">symbol_map</span><span class="o">=</span><span class="p">{</span><span class="s1">&#39;x&#39;</span><span class="p">:</span> <span class="mf">1.5</span><span class="p">,</span> <span class="s1">&#39;y&#39;</span><span class="p">:</span> <span class="mi">10</span><span class="p">})</span>
<span class="gh">Out[7]: </span><span class="go">7.5</span>
</pre></div>
</div>
</section>
</section>
<section id="avoiding-recursion">
<h2><span class="section-number">9.5. </span>Avoiding recursion<a class="headerlink" href="#avoiding-recursion" title="Permalink to this headline">¶</a></h2>
<p>The recursive tree visitors we have written require very few lines of code, and
very succinctly express the algorithm they represent. However, in most
programming languages (including Python), recursion is a relatively inefficient
process. The reason for this is that it creates a deep <a class="reference internal" href="6_exceptions.html#term-call-stack"><span class="xref std std-term">call stack</span></a>
requiring a new <a class="reference internal" href="6_exceptions.html#term-stack-frame"><span class="xref std std-term">stack frame</span></a> for every level of recursion. In extreme
cases, this can exceed Python’s limit on recursion depth and result in a
<a class="reference external" href="https://docs.python.org/3/library/exceptions.html#RecursionError" title="(in Python v3.10)"><code class="xref py py-class docutils literal notranslate"><span class="pre">RecursionError</span></code></a>.</p>
<p>In order to avoid this, we can think a little more about what a recursive
function actually does. In fact, a recursive function is using the <a class="reference internal" href="6_exceptions.html#term-call-stack"><span class="xref std std-term">call
stack</span></a> to control the order in which operations are evaluated. We could do the
same using a <a class="reference internal" href="5_abstract_data_types.html#term-stack"><span class="xref std std-term">stack</span></a> to store which tree nodes still need processing.
There are a number of ways to do this, but one particular algorithm emerges if
we wish to be able to represent expressions not only as trees but as more
general <a class="reference internal" href="#term-DAG"><span class="xref std std-term">directed acyclic graphs</span></a>.</p>
</section>
<section id="representing-expressions-as-dags">
<h2><span class="section-number">9.6. </span>Representing expressions as <a class="reference internal" href="#term-DAG"><span class="xref std std-term">DAGs</span></a><a class="headerlink" href="#representing-expressions-as-dags" title="Permalink to this headline">¶</a></h2>
<p>If we treat an expression as a tree, then any repeated subexpressions will be
duplicated in the tree. Consider, for example, <span class="math notranslate nohighlight">\(x^2 + 3/x^2\)</span>. If we create
a tree of this expression, then <span class="math notranslate nohighlight">\(x^2\)</span> will occur twice, and any operation
that we perform on <span class="math notranslate nohighlight">\(x^2\)</span> will have to be done twice. If, on the other hand, we
treat the expression as a more general <a class="reference internal" href="#term-directed-acyclic-graph"><span class="xref std std-term">directed acyclic graph</span></a>, then the
single subexpression <span class="math notranslate nohighlight">\(x^2\)</span> can have multiple parents, and so can appear as
an operand more than once. <a class="reference internal" href="#tree-vs-dag"><span class="std std-numref">Fig. 9.7</span></a> illustrates this distinction.</p>
<figure class="align-default" id="id22">
<span id="tree-vs-dag"></span><div class="graphviz"><object data="_images/graphviz-6ae4f72fc294a94b6b6f3d73b5da533905018f08.svg" type="image/svg+xml" class="graphviz">
<p class="warning">strict digraph{
    a1 [label=&quot;+&quot;]
    pow1 [label=&quot;^&quot;]
    x1 [label=&quot;x&quot;]
    n1 [label=&quot;2&quot;]
    a1 -&gt; pow1
    pow1 -&gt; x1
    pow1 -&gt; n1
    m1 [label=&quot;/&quot;]
    n0 [label=3]
    pow2 [label=&quot;^&quot;]
    x2 [label=&quot;x&quot;]
    n2 [label=&quot;2&quot;]
    a1 -&gt; m1
    m1 -&gt; n0
    m1 -&gt; pow2
    pow2 -&gt; x2
    pow2 -&gt; n2

    a3 [label=&quot;+&quot;, ordering=&quot;out&quot;]
    pow3 [label=&quot;^&quot;]
    x3 [label=&quot;x&quot;]
    n3 [label=&quot;2&quot;]
    a3 -&gt; pow3

    pow3 -&gt; x3
    pow3 -&gt; n3
    m3 [label=&quot;/&quot;, ordering=&quot;out&quot;]
    n4 [label=3]
    a3 -&gt; m3
    m3 -&gt; n4
    m3 -&gt; pow3

}</p></object></div>
<figcaption>
<p><span class="caption-number">Fig. 9.7 </span><span class="caption-text"><a class="reference internal" href="#term-tree"><span class="xref std std-term">Tree</span></a> (left) and <a class="reference internal" href="#term-DAG"><span class="xref std std-term">DAG</span></a> (right) representations
of the expression <span class="math notranslate nohighlight">\(x^2 + 3/x^2\)</span>. Notice that the <a class="reference internal" href="#term-DAG"><span class="xref std std-term">DAG</span></a>
representation avoids the duplication of the <span class="math notranslate nohighlight">\(x^2\)</span> term.</span><a class="headerlink" href="#id22" title="Permalink to this image">¶</a></p>
</figcaption>
</figure>
<p>The difference between a tree and a DAG may seem small in the tiny examples we
can print on our page, but realistic applications of computer algebra can easily
create expressions with thousands or tens of thousands of terms, in which larger
common subexpressions themselves contain multiple instances of smaller
subexpressions. The repetition of common terms, and therefore data size and
computational cost, induced by the tree representation is exponential in the
depth of nesting. This can easily make the difference between a computation that
completes in a fraction of a second, and one which takes hours to complete or
which exhausts the computer’s memory and therefore fails to complete at all!</p>
<section id="building-expression-dags">
<h3><span class="section-number">9.6.1. </span>Building expression <a class="reference internal" href="#term-DAG"><span class="xref std std-term">DAGs</span></a><a class="headerlink" href="#building-expression-dags" title="Permalink to this headline">¶</a></h3>
<p>Using somewhat more complex data structures, it is possible to create
expressions that automatically result in <a class="reference internal" href="#term-DAG"><span class="xref std std-term">DAGs</span></a> rather than
<a class="reference internal" href="#term-tree"><span class="xref std std-term">trees</span></a>.  That is beyond the scope of this course, but we can
construct expression DAGs using our existing tools, at the expense of a little
extra code. Take as an example the expression we used above: <span class="math notranslate nohighlight">\(x^2 +
3/x^2\)</span>. If we write:</p>
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="gp">In [1]: </span><span class="kn">from</span> <span class="nn">expressions</span> <span class="kn">import</span> <span class="n">Symbol</span>

<span class="gp">In [2]: </span><span class="n">x</span> <span class="o">=</span> <span class="n">Symbol</span><span class="p">(</span><span class="s1">&#39;x&#39;</span><span class="p">)</span>

<span class="gp">In [3]: </span><span class="n">expr</span> <span class="o">=</span> <span class="n">x</span><span class="o">**</span><span class="mi">2</span> <span class="o">+</span> <span class="mi">3</span><span class="o">/</span><span class="n">x</span><span class="o">**</span><span class="mi">2</span>
</pre></div>
</div>
<p>then each occurrence of <code class="xref py py-obj docutils literal notranslate"><span class="pre">x**2</span></code> creates a separate <code class="xref py py-class docutils literal notranslate"><span class="pre">Expression</span></code> object and
we have a tree. However, if we instead write:</p>
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="gp">In [1]: </span><span class="kn">from</span> <span class="nn">expressions</span> <span class="kn">import</span> <span class="n">Symbol</span>

<span class="gp">In [2]: </span><span class="n">x</span> <span class="o">=</span> <span class="n">Symbol</span><span class="p">(</span><span class="s1">&#39;x&#39;</span><span class="p">)</span>

<span class="gp">In [3]: </span><span class="n">x2</span> <span class="o">=</span> <span class="n">x</span><span class="o">**</span><span class="mi">2</span>

<span class="gp">In [4]: </span><span class="n">expr</span> <span class="o">=</span> <span class="n">x2</span> <span class="o">+</span> <span class="mi">3</span><span class="o">/</span><span class="n">x2</span>
</pre></div>
</div>
<p>then we now have a DAG in which the two occurrences of the <span class="math notranslate nohighlight">\(x^2\)</span> term
refer to the same <code class="xref py py-obj docutils literal notranslate"><span class="pre">x**2</span></code> object.</p>
</section>
<section id="dag-visitors">
<h3><span class="section-number">9.6.2. </span><a class="reference internal" href="#term-DAG"><span class="xref std std-term">DAG</span></a> visitors<a class="headerlink" href="#dag-visitors" title="Permalink to this headline">¶</a></h3>
<p>Even if we represent an expression as a DAG rather than a tree, the simple
recursive tree visitors we have used thusfar will undo all of our good work,
because common subexpressions will be visited via each parent expression, rather
than just once. This compounds the disadvantages of recursive visitors that we
discussed above. Instead, we can construct a postorder DAG visitor using a
<a class="reference internal" href="5_abstract_data_types.html#term-stack"><span class="xref std std-term">stack</span></a> to replace the recursion in keeping track of what to evaluate
next, and a <a class="reference external" href="https://docs.python.org/3/library/stdtypes.html#dict" title="(in Python v3.10)"><code class="xref py py-class docutils literal notranslate"><span class="pre">dict</span></code></a> to record the nodes we have already visited, and the
results of visiting them. <a class="reference internal" href="#nonrecursive-postvisit"><span class="std std-numref">Listing 9.8</span></a> illustrates one such
algorithm.</p>
<div class="literal-block-wrapper docutils container" id="id23">
<span id="nonrecursive-postvisit"></span><div class="code-block-caption"><span class="caption-number">Listing 9.8 </span><span class="caption-text">Pythonic <a class="reference internal" href="3_objects.html#term-pseudocode"><span class="xref std std-term">pseudocode</span></a> for a non-recursive postorder <a class="reference internal" href="#term-DAG"><span class="xref std std-term">DAG</span></a> visitor.</span><a class="headerlink" href="#id23" title="Permalink to this code">¶</a></div>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="linenos"> 1</span><span class="k">def</span> <span class="nf">visit</span><span class="p">(</span><span class="n">expr</span><span class="p">,</span> <span class="n">visitor</span><span class="p">):</span>
<span class="linenos"> 2</span>    <span class="n">stack</span> <span class="o">=</span> <span class="p">[]</span>
<span class="linenos"> 3</span>    <span class="n">visited</span> <span class="o">=</span> <span class="p">{}</span>
<span class="linenos"> 4</span>    <span class="n">push</span> <span class="n">expr</span> <span class="n">onto</span> <span class="n">stack</span>
<span class="linenos"> 5</span>    <span class="k">while</span> <span class="n">stack</span><span class="p">:</span>
<span class="linenos"> 6</span>        <span class="n">e</span> <span class="o">=</span> <span class="n">pop</span> <span class="kn">from</span> <span class="nn">stack</span>
<span class="linenos"> 7</span>        <span class="n">unvisited_children</span> <span class="o">=</span> <span class="p">[]</span>
<span class="linenos"> 8</span>        <span class="k">for</span> <span class="n">o</span> <span class="ow">in</span> <span class="n">e</span><span class="o">.</span><span class="n">operands</span><span class="p">:</span>
<span class="linenos"> 9</span>            <span class="k">if</span> <span class="n">o</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">visited</span><span class="p">:</span>
<span class="linenos">10</span>                <span class="n">push</span> <span class="n">o</span> <span class="n">onto</span> <span class="n">unvisited_children</span>
<span class="linenos">11</span>
<span class="linenos">12</span>        <span class="k">if</span> <span class="n">unvisited_children</span><span class="p">:</span>
<span class="linenos">13</span>            <span class="n">push</span> <span class="n">e</span> <span class="n">onto</span> <span class="n">stack</span> <span class="c1"># Not ready to visit this node yet.</span>
<span class="linenos">14</span>            <span class="c1"># Need to visit children before e.</span>
<span class="linenos">15</span>            <span class="n">push</span> <span class="nb">all</span> <span class="n">unvisted_children</span> <span class="n">onto</span> <span class="n">stack</span>
<span class="linenos">16</span>        <span class="k">else</span><span class="p">:</span>
<span class="linenos">17</span>            <span class="c1"># Any children of e have been visited, so we can visit it.</span>
<span class="linenos">18</span>            <span class="n">visited</span><span class="p">[</span><span class="n">e</span><span class="p">]</span> <span class="o">=</span> <span class="n">visitor</span><span class="p">(</span><span class="n">e</span><span class="p">,</span> <span class="o">*</span><span class="p">(</span><span class="n">visited</span><span class="p">(</span><span class="n">o</span><span class="p">)</span> <span class="k">for</span> <span class="n">o</span> <span class="ow">in</span> <span class="n">e</span><span class="o">.</span><span class="n">operands</span><span class="p">))</span>
<span class="linenos">19</span>
<span class="linenos">20</span>    <span class="c1"># When the stack is empty, we have visited every subexpression,</span>
<span class="linenos">21</span>    <span class="c1"># including expr itself.</span>
<span class="linenos">22</span>    <span class="k">return</span> <span class="n">visited</span><span class="p">[</span><span class="n">expr</span><span class="p">]</span>
</pre></div>
</div>
</div>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>Every operation we have defined on a symbolic mathematical expression
defined as a <a class="reference internal" href="#term-tree"><span class="xref std std-term">tree</span></a> or a <a class="reference internal" href="#term-DAG"><span class="xref std std-term">DAG</span></a> has produced a new <a class="reference internal" href="#term-tree"><span class="xref std std-term">tree</span></a>
or <a class="reference internal" href="#term-DAG"><span class="xref std std-term">DAG</span></a> as a result. This matches mathematical convention: operations
produce new expressions, they don’t change their inputs. This is an
important design principle of symbolic mathematical software. The confusion
that frequently results from modifying symbolic expressions in-place far
outweighs any possible advantage of not creating new objects.</p>
</div>
</section>
</section>
<section id="differentiation-as-an-expression-visitor">
<h2><span class="section-number">9.7. </span>Differentiation as an expression visitor<a class="headerlink" href="#differentiation-as-an-expression-visitor" title="Permalink to this headline">¶</a></h2>
<p>In <a class="reference internal" href="#expr-trees"><span class="std std-numref">Section 9.4</span></a> we showed how a tree visitor could implement the
evaluation of a symbolic expression. You might very well protest that if the
only thing you wanted to do was evaluate arithmetic expressions then you could
have just written a Python function and avoided a lot of code. In fact, almost
any algebraic manipulation that you could conduct with pen and paper can be
automated using expression visitors. We will illustrate this by sketching how
differentiation can be achieved using a visitor function.</p>
<p>Let’s first consider terminals. Numbers are easy: the derivative of any number
with respect to any symbol is simply 0. Symbols are nearly as straightforward.
The derivative of a symbol with respect to itself is 1, while the derivative of
a symbol with respect to any other symbol is 0. Because terminals have no
operands, the implementation of differentiation when visiting a terminal is
particularly easy. Note that the symbol with respect to which we are
differentiating will need to be passed in to the visitor. This can be achieved
with a keyword argument in a manner analogous to <code class="xref py py-obj docutils literal notranslate"><span class="pre">tree_map</span></code> in
<a class="reference internal" href="#tree-evaluate"><span class="std std-numref">Listing 9.6</span></a>.</p>
<p>The differentiation of operators is achieved by an applying the chain rule. For
a binary operator <span class="math notranslate nohighlight">\(\odot\)</span>, with operands <span class="math notranslate nohighlight">\(o_0\)</span> and <span class="math notranslate nohighlight">\(o_1\)</span>, the
chain rule is given by:</p>
<div class="math notranslate nohighlight" id="equation-10-trees-and-directed-acyclic-graphs-0">
<span class="eqno">(9.1)<a class="headerlink" href="#equation-10-trees-and-directed-acyclic-graphs-0" title="Permalink to this equation">¶</a></span>\[\frac{\partial\, (o_0 \odot o_1)}{\partial x} =
\frac{\partial o_0}{\partial x} \frac{\partial\, (o_0 \odot o_1)}{\partial o_0}
+ \frac{\partial o_1}{\partial x} \frac{\partial\, (o_0 \odot o_1)}{\partial o_1}\]</div>
<p>For example if the operator is multiplication, then:</p>
<div class="math notranslate nohighlight" id="equation-10-trees-and-directed-acyclic-graphs-1">
<span class="eqno">(9.2)<a class="headerlink" href="#equation-10-trees-and-directed-acyclic-graphs-1" title="Permalink to this equation">¶</a></span>\[\frac{\partial\, o_0 o_1}{\partial o_0} = o_1\]</div>
<p>and the product rule follows immediately. Similarly, the sum and quotient
rules for differentiation are simply special cases of the chain rule. This means
that the particular implementation of differentiation for a given
<code class="xref py py-class docutils literal notranslate"><span class="pre">Operator</span></code> subclass simply encodes the version of the chain rule for that
operator. This will require the original operands to the operator, which are
available from the operator object itself, and the results of differentiating
the operands, which are given by the <code class="xref py py-obj docutils literal notranslate"><span class="pre">*o</span></code> argument to the visitor function.</p>
</section>
<section id="glossary">
<h2><span class="section-number">9.8. </span>Glossary<a class="headerlink" href="#glossary" title="Permalink to this headline">¶</a></h2>
<dl class="glossary simple">
<dt id="term-child-node">child node<a class="headerlink" href="#term-child-node" title="Permalink to this term">¶</a></dt><dd><p>The children of a node in a <a class="reference internal" href="#term-DAG"><span class="xref std std-term">DAG</span></a> are the targets of the edges
emerging from that node. In this context, the node from which these
edges emanate is called the <a class="reference internal" href="#term-parent-node"><span class="xref std std-term">parent node</span></a>.</p>
</dd>
<dt id="term-directed-acyclic-graph">directed acyclic graph<a class="headerlink" href="#term-directed-acyclic-graph" title="Permalink to this term">¶</a></dt><dt id="term-DAG">DAG<a class="headerlink" href="#term-DAG" title="Permalink to this term">¶</a></dt><dd><p>A <a class="reference internal" href="#term-graph"><span class="xref std std-term">graph</span></a> in which the edges are directed (i.e. the edges point from
one vertex to another) and where there are no cycles of edges.</p>
</dd>
<dt id="term-edge">edge<a class="headerlink" href="#term-edge" title="Permalink to this term">¶</a></dt><dd><p>A connection between two nodes in a <a class="reference internal" href="#term-graph"><span class="xref std std-term">graph</span></a>. In a directed graph,
the edges have an orientation, from a source node to a target node.</p>
</dd>
<dt id="term-graph">graph<a class="headerlink" href="#term-graph" title="Permalink to this term">¶</a></dt><dd><p>An <a class="reference internal" href="5_abstract_data_types.html#term-abstract-data-type"><span class="xref std std-term">abstract data type</span></a> comprising a set of nodes or vertices
<span class="math notranslate nohighlight">\(V\)</span> and a set of edges <span class="math notranslate nohighlight">\(E\)</span> each of which connects two vertices.</p>
</dd>
<dt id="term-graph-visitor">graph visitor<a class="headerlink" href="#term-graph-visitor" title="Permalink to this term">¶</a></dt><dd><p>A function which iterates over all of the nodes of a graph, calling
calling a visitor function for each node.</p>
</dd>
<dt id="term-leaf-node">leaf node<a class="headerlink" href="#term-leaf-node" title="Permalink to this term">¶</a></dt><dd><p>A node in a <a class="reference internal" href="#term-DAG"><span class="xref std std-term">DAG</span></a> with no <a class="reference internal" href="#term-child-node"><span class="xref std std-term">children</span></a>.</p>
</dd>
<dt id="term-parent-node">parent node<a class="headerlink" href="#term-parent-node" title="Permalink to this term">¶</a></dt><dd><p>From the perspective of a <a class="reference internal" href="#term-child-node"><span class="xref std std-term">child node</span></a>, the source of an incoming edge.</p>
</dd>
<dt id="term-postorder-traversal">postorder traversal<a class="headerlink" href="#term-postorder-traversal" title="Permalink to this term">¶</a></dt><dd><p>A <a class="reference internal" href="#term-graph-visitor"><span class="xref std std-term">visitor</span></a> for a <a class="reference internal" href="#term-DAG"><span class="xref std std-term">DAG</span></a> in
which the each parent node is visited <em>after</em> its <a class="reference internal" href="#term-child-node"><span class="xref std std-term">children</span></a>.</p>
</dd>
<dt id="term-preorder-traversal">preorder traversal<a class="headerlink" href="#term-preorder-traversal" title="Permalink to this term">¶</a></dt><dd><p>A <a class="reference internal" href="#term-graph-visitor"><span class="xref std std-term">visitor</span></a> for a <a class="reference internal" href="#term-DAG"><span class="xref std std-term">DAG</span></a> in which each parent
node is visited <em>before</em> its <a class="reference internal" href="#term-child-node"><span class="xref std std-term">children</span></a>.</p>
</dd>
<dt id="term-root-node">root node<a class="headerlink" href="#term-root-node" title="Permalink to this term">¶</a></dt><dd><p>A node in a <a class="reference internal" href="#term-DAG"><span class="xref std std-term">DAG</span></a> with no <a class="reference internal" href="#term-parent-node"><span class="xref std std-term">parent</span></a>.</p>
</dd>
<dt id="term-single-dispatch-function">single dispatch function<a class="headerlink" href="#term-single-dispatch-function" title="Permalink to this term">¶</a></dt><dd><p>A function with a single name but multiple implementations. The
implementation which executes when the function is called is chosen
based on the <a class="reference external" href="https://docs.python.org/3/library/functions.html#type" title="(in Python v3.10)"><code class="xref py py-class docutils literal notranslate"><span class="pre">type</span></code></a> of the first argument to the function. The
<a class="reference external" href="https://docs.python.org/3/library/functools.html#functools.singledispatch" title="(in Python v3.10)"><code class="xref py py-func docutils literal notranslate"><span class="pre">functools.singledispatch()</span></code></a> function facilitates the creation of
single dispatch functions.</p>
</dd>
<dt id="term-tree">tree<a class="headerlink" href="#term-tree" title="Permalink to this term">¶</a></dt><dd><p>A <a class="reference internal" href="#term-DAG"><span class="xref std std-term">DAG</span></a> in which every vertex is the target of at
most one edge.</p>
</dd>
</dl>
</section>
<section id="exercises">
<h2><span class="section-number">9.9. </span>Exercises<a class="headerlink" href="#exercises" title="Permalink to this headline">¶</a></h2>
<p>Obtain the <a class="reference external" href="https://classroom.github.com/a/429nBtsQ">skeleton code for these exercises from GitHub classroom</a>. You should also update your clone
of the course repository to ensure you have the latest version of the
<a class="reference internal" href="example_code.html#module-example_code" title="example_code"><code class="xref py py-mod docutils literal notranslate"><span class="pre">example_code</span></code></a> package.</p>
<div class="proof proof-type-exercise" id="id24">
<span id="ex-expr"></span>
    <div class="proof-title">
        <span class="proof-type">Exercise 9.6</span>
        
    </div><div class="proof-content">
<p>In the skeleton repository for this week, create a <a class="reference internal" href="2_programs_in_files.html#term-package"><span class="xref std std-term">package</span></a>
<code class="xref py py-mod docutils literal notranslate"><span class="pre">expressions</span></code> which implements the class hierarchy in
<a class="reference internal" href="#expr-hierarchy"><span class="std std-numref">Section 9.4.1</span></a>. When implementing <a class="reference external" href="https://docs.python.org/3/reference/datamodel.html#object.__str__" title="(in Python v3.10)"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__str__()</span></code></a>, use the
symbols <code class="xref py py-obj docutils literal notranslate"><span class="pre">+</span></code>, <code class="xref py py-obj docutils literal notranslate"><span class="pre">-</span></code>, <code class="xref py py-obj docutils literal notranslate"><span class="pre">*</span></code>, <code class="xref py py-obj docutils literal notranslate"><span class="pre">/</span></code>, and <code class="xref py py-obj docutils literal notranslate"><span class="pre">^</span></code>. The names <code class="xref py py-class docutils literal notranslate"><span class="pre">Symbol</span></code>,
<code class="xref py py-class docutils literal notranslate"><span class="pre">Number</span></code>, <code class="xref py py-class docutils literal notranslate"><span class="pre">Add</span></code>, <code class="xref py py-class docutils literal notranslate"><span class="pre">Sub</span></code>, <code class="xref py py-class docutils literal notranslate"><span class="pre">Mul</span></code>, <code class="xref py py-class docutils literal notranslate"><span class="pre">Div</span></code>, and
<code class="xref py py-class docutils literal notranslate"><span class="pre">Pow</span></code> should be directly importable in the <code class="xref py py-mod docutils literal notranslate"><span class="pre">expressions</span></code> <a class="reference internal" href="2_programs_in_files.html#term-namespace"><span class="xref std std-term">namespace</span></a>.</p>
</div></div><div class="proof proof-type-exercise" id="id25">

    <div class="proof-title">
        <span class="proof-type">Exercise 9.7</span>
        
    </div><div class="proof-content">
<p>Write a function importable as <code class="xref py py-func docutils literal notranslate"><span class="pre">expressions.postvisitor()</span></code> with the same
interface as <a class="reference internal" href="#postorder-recursive-kwargs"><span class="std std-numref">Listing 9.7</span></a>. Your implementation, however,
should not be recursive, and should only visit repeated subexpressions once,
no matter how many times they occur in the expression.</p>
</div></div><div class="proof proof-type-exercise" id="id26">

    <div class="proof-title">
        <span class="proof-type">Exercise 9.8</span>
        
    </div><div class="proof-content">
<p>Write a <a class="reference internal" href="#term-single-dispatch-function"><span class="xref std std-term">single dispatch function</span></a> importable as
<code class="xref py py-func docutils literal notranslate"><span class="pre">expressions.differentiate()</span></code> which has the correct interface to be
passed to <code class="xref py py-func docutils literal notranslate"><span class="pre">expressions.postvisitor()</span></code> or
<code class="xref py py-func docutils literal notranslate"><span class="pre">example_code.expression_tools.postvisitor()</span></code> and which differentiates the
expression provided with respect to a symbol whose name is passed as the
string <a class="reference external" href="https://docs.python.org/3/glossary.html#term-argument" title="(in Python v3.10)"><span class="xref std std-term">keyword argument</span></a> <code class="xref py py-obj docutils literal notranslate"><span class="pre">var</span></code>.</p>
<p>As a simplification, the tests will assume that <code class="xref py py-obj docutils literal notranslate"><span class="pre">var</span></code> does not appear in an
exponent. As an extension, you could consider that case too, but you’d
probably need to extend your symbolic language to include the natural
logarithm as a symbolic function.</p>
</div></div><p class="rubric">Footnotes</p>
<dl class="footnote brackets">
<dt class="label" id="tree-def"><span class="brackets"><a class="fn-backref" href="#id2">1</a></span></dt>
<dd><p>This definition of a tree matches computer science usage and is
the relevant one for the applications we will study. There is a slightly
different definition of a tree common in mathematical graph theory.</p>
</dd>
<dt class="label" id="splat"><span class="brackets"><a class="fn-backref" href="#id1">2</a></span></dt>
<dd><p>Python language pedants will observe that strictly speaking neither
<code class="xref py py-obj docutils literal notranslate"><span class="pre">*</span></code> nor <code class="xref py py-obj docutils literal notranslate"><span class="pre">**</span></code> are operators, and that they are simply an unnamed syntax for
argument packing and unpacking. This is both correct and unhelpful, since it
is useful in many contexts to be able to give a name to the <code class="xref py py-obj docutils literal notranslate"><span class="pre">*</span></code> and <code class="xref py py-obj docutils literal notranslate"><span class="pre">**</span></code>
symbols when used in this way.</p>
</dd>
<dt class="label" id="single"><span class="brackets"><a class="fn-backref" href="#id3">3</a></span></dt>
<dd><p>The <em>single</em> in <em>single dispatch</em> indicates that the
choice of function implementation is made on the basis of the type of one
argument, typically the first. Multiple dispatch, in which the function
implementation is chosen on the basis of multiple function arguments, is
also possible, and is a key feature of <a class="reference external" href="https://julialang.org">the Julia programming language</a>.</p>
</dd>
</dl>
</section>
</section>


            <div class="clearer"></div>
          </div>
        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="footer" role="contentinfo">
        &#169; Copyright 2019-2021, David A. Ham. Modified by Patrick E. Farrell.
      Created using <a href="https://www.sphinx-doc.org/">Sphinx</a> 4.5.0.
    </div>
  </body>
</html>